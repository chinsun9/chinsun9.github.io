{"pages":[{"title":"404 page","text":"친성의 블로그 Opps! Page Not Found Let's go home .msg { text-align: center; } iframe { width: 100%; height: 820px; border: 0; }","link":"/404.html"},{"title":"project","text":"프로젝트 페이지 2020 Nodejs Express WEB Nodejs Express WEB (Docker) Image Finder (Swift) Percentage Calculator (React) Banner Maker (HTML) Banner Maker (React) Random Color (HTML) Chat App (NodeJs &amp; Socket.IO ) Open Port Check WEB (NodeJs) Input Overlay (Electron)","link":"/project/index.html"},{"title":"about","text":"hello world! 친성의 개발 블로그입니다. 저의 T는 … (작성중) 스택 aws EC2 Lambda layer CloudFormation SAM RDS DynamoDB S3 git github github desktop gitignore docker nodejs express ejs sam electron hexo javascript js json promise async array api react typescript redux reducer action context state ref typescript typedoc java javadoc spring boot gradle unity swift(ios) web(html, css, js) mvc pattern ajax fetch api bootstrap chart.js Rest api postman Chrome DevTools open api 도로명 주소 api kakao api 이미지 검색 DB erd sql sqldump vscode prettier Live Server Remote - SSH Remote - WSL Material Icon Theme markdown md draw.io material.io cmd .bat batch file yml yaml config network wireshark packet capture OS Windows Linux Telegram bot YouTube photoshop vegas","link":"/about/index.html"}],"posts":[{"title":"AWS ELB를 사용할 때 express morgan 로깅 주의점","text":"morgan 로깅할 때, 사용자의 ip를 기록하는 :remote-addr 토큰은 req.ip 를 사용한다. ELB, 로드밸런서를 사용하면 사용자의 ip가 아니라, ELB의 ip가 기록된다. 그래서 사용자의 ip를 가져오려면 x-forwarded-for 헤더의 내용을 봐야한다. 1const ip = req.headers['x-forwarded-for'] || req.connection.remoteAddress; morgan customapp.js12345678910111213141516171819202122(...)app.use( morgan( function (tokens, req, res) { return [ req.headers['x-forwarded-for'] || req.connection.remoteAddress, req.ip, // == :remote-addr tokens.method(req, res), tokens.url(req, res), tokens.status(req, res), ].join(' '); }, { skip: function (req, res) { return res.statusCode &lt; 400; }, } ));(...) 이런식으로 커스텀할 수 있다. req.headers['x-forwarded-for']의 내용은 1X-Forwarded-For: &lt;client&gt;, &lt;proxy1&gt;, &lt;proxy2&gt; 이런식으로 가장 앞의 ip가 사용자 ip이다. 뒤로 ,로 나열되는 ip는 프록시임으로 당황하지 말자 12345{ skip: function (req, res) { return res.statusCode &lt; 400; },} morgan(f(), {}) morgan 두번째 인자로 옵션을 넣을 수 있다. skip을 주면 특정 경우에서 로깅을 하지 않는 옵션이다 return res.statusCode &lt; 400;이런식으로 하면 400이하의 스테이터스 코드일 때, 로깅을 하지 않는다는 의미이다. 이 경우 404, 500 같은 에러들만 로깅된다. 참고 Express morgan middleware X-Forwarded-For","link":"/2020/11/09/AWS-ELB%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%A0-%EB%95%8C-express-morgan-%EB%A1%9C%EA%B9%85-%EC%A3%BC%EC%9D%98%EC%A0%90/"},{"title":"Banner Maker 클론코딩","text":"banner-maker/banner-maker를 클론코딩해보았다. 내 두번째 리액트 프로젝트..! 데모 Banner Maker (React) 기능 캔버스 크기 조절 실시간 캔버스 업데이트 폰트 사이즈 조절 폰트색 조절 캔버스색에 따른 폰트색 자동조절 캔버스색 조절 랜덤 캠버스색 이미지로 다운로드 클립보드로 카피 컬러 히스토리 기능 컬러 히스토리 임포트, 익스포트 기능 후기 타입스크립트 공부 겸 리액트도 같이 하자는 생각으로 리액트 타입스크립트를 시작했다. velopert님의 리액트 프로젝트에서 타입스크립트 사용하기 글을 보고 따라하다가 튜토리얼을 통해 잘 만들어진 프로젝트 구조를 기반으로 만들었다. 리액트가 아직 익숙하지 않은데 리액트의 훅이라던지 처음부터 고급??개념들을 사용하니까 사실 뭐가 좋은지, 이렇게 써서 좋은점이 무엇인지.. 이 개념을 도입하기전의 것들을 시도해보지 않았기 때문에 막연한 감이 있었다. 나는 공부할때 이론보단 무조건 실기이고, 일단 만들어보면서 익히고 이해하자라는 주의이다. 그래서 이것저것 쉽게만들 수 있다고 생각한다. (나중에 보면 코드가 엄청 구릴지라도..) 이번에 만들면서 신경쎃던 것은 사용성..?? 인 것같다. 나는 보통 이미지를 ctrl c 카톡에다가 ctrl v 하여 톡방에 올리는데 그걸위한 copy clipboard 버튼을 만들었다. 저장후 이미지 올리기는 귀찮기 때문에.. 또 랜덤 칼러 버튼을 만들어서 색을 쇼핑했다. js/index.jshtml-banner-maker/commit/5cccc1594309f732ea8edd8ca08c91800d97d3171234567891011121314// https://stackoverflow.com/questions/3942878/how-to-decide-font-color-in-white-or-black-depending-on-background-color/** * Get color (black/white) depending on bgColor so it would be clearly seen. * @param bgColor * @returns {string} */function getColorByBgColor(bgColor) { if (!bgColor) { return ''; } return parseInt(bgColor.replace('#', ''), 16) &gt; 0xffffff / 2 ? '#000' : '#fff';} 사용해보면 알겠지만 랜덤으로 생성된 배경색에 따라 폰트색도 검정색/흰색 적절한게 선택된다. 컬러 히스토리 기능이다. copy 버튼이나 download 버튼을 누르면 해당 배경색과, 폰트색이 히스토리에 저장된다. 만약에 같은 최근 히스토리에 저장된 색과 같은 색이면 저장하지 않도록 하였다. 버튼을 누를때마다 증식되지 않도록.. export 버튼을 눌러 현재 저장된 컬러 히스토리를 json 파일로 내보내는 기능도있다. 깃허브 페이지를 이용해 호스팅하기때문에, 내 앱은 정적이다. 어떻게 히스토리를 저장하고 불러올까 생각하다가 json 파일로 내보내고 다시 불러오도록 만들게 되었다. 개선방향 칼러픽커에서 알파값을 바꿀 수 있도록 하기 폰트 변경 기능 textarea를 div안에 넣어버리기..? (html2canvas 사용해보기) json파일로부터 컬러히스토리 임포트할때 덮어쓰기가 아니라 병합으로 불러오기 src/modules/common/copyToClipboard.js1234567891011export function copyToClipboard() { const canvas = document.querySelector(`#myCanvas`); if (!canvas) { return; } canvas.toBlob(function (blob) { // eslint-disable-next-line no-undef const item = new ClipboardItem({ 'image/png': blob }); navigator.clipboard.write([item]); });} 클립보드 복사 js 코드를 ts로 변환하지 못한 코드.. 소스코드 react-banner-maker 참고 리액트 타입스크립트 공부 ; 리액트 프로젝트에서 타입스크립트 사용하기","link":"/2020/11/06/Banner-maker-%ED%81%B4%EB%A1%A0%EC%BD%94%EB%94%A9/"},{"title":"124 나라 숫자","text":"124 나라 숫자123456789101112131415161718192021222324252627282930313233343536// https://programmers.co.kr/learn/courses/30/lessons/12899function solution12909(n) { var answer = []; var arr = ''; var N = n; var seq = ['4', '1', '2']; // console.log(seq[seq.length - 1]); while (true) { var tmp = n % 3; answer.push(tmp); // if (n &lt;= 2) { // break; // } if (tmp == 0) { n = (n - tmp - 3) / 3; } else { n = (n - tmp) / 3; } if (n == 0) { break; } } while (answer.length != 0) { arr += seq[answer.pop()]; } // console.log(answer); // console.log(N, arr); // console.log(&quot;------------&quot;); return arr;} 해설 124라는 나라의 이상한 진법으로 변환해야 하는 문제이다. 10진법 124 나라 10진법 124 나라 1 1 6 14 2 2 7 21 3 4 8 22 4 11 9 24 5 12 10 41 이렇게 이상한 숫자로 변환시키는 문제이다 3진법 같아 보이지만 여기에는 함정이 있다…. 3진법이 아닌데 3개 숫자로만 표현해야한다. 경험으로 알게된.. 자릿수가 바뀔때 이상하게 바뀐다는 건데.. 나머지가 0이 될 경우에 == n이 3의 배수의 경우에 추가로 처리해줘야한다. 이해?를 돕기위해 그림을 그렸다 왼쪽이 일반적인.. 상식적인 3진수이고 오른쪽이 124 나라의 수이다. 중간은 124 나라의 수인데, 3진수와 시작을 똑같이 하기 위해 조작한 것이다. 3진수와 중간을 비교해보면 중간중간 정신나간 부분이 보인다 이런 특징? 때문에 124나라는 적은 자릿수로 더 많은 숫자를 표현할 수 있다. 이문제는 해결법을 짠하고 알아냈다기보다 계속 해보면서 알게된 규칙들을 적용시키면서 풀린거라 설명을 잘 못하겠다.. 숫자 때문에 헷갈려 죽을뻔.. 아무튼 정신나간 124 나라이다.","link":"/2020/09/18/124-%EB%82%98%EB%9D%BC-%EC%88%AB%EC%9E%90/"},{"title":"2016년","text":"2016년1234567891011121314151617181920212223242526272829303132// https://programmers.co.kr/learn/courses/30/lessons/12901// 1월:31일// 2월:29일// 3월:31일// 4월:30일// 5월:31일// 6월:30일// 7월:31일// 8월:31일// 9월:30일// 10월:31일// 11월:30일// 12월:31일function solution(a, b) { const days = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; const dow = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT']; let eachFirstDow = [5]; let tmp; // setup process for (let i = 1; i &lt; a; i++) { tmp = days[i - 1] % 7; console.log(i + 1, dow[(eachFirstDow[i - 1] + tmp) % 7]); eachFirstDow[i] = (eachFirstDow[i - 1] + tmp) % 7; } eachFirstDow.forEach((item) =&gt; { console.log(dow[item]); }); tmp = (b - 1) % 7; return dow[(eachFirstDow[a - 1] + tmp) % 7];}result = solution(10, 1);result = solution(5, 24); 해설 2016년은 윤년이다. a월 b일을 입력받았을때 무슨요일인지 반환하는 문제이다 나는 dow에 요일을 넣었다. 1월 1일은 무슨 요일인지 확인한다. 확인 결과 금요일이다. 첫번째 반복문에서 각 월 1일의 요일을 구한다. a월 1일의 요일에서 (b-1)일을 더하고 7로 나누면 해당일의 요일을 구할 수 있다.","link":"/2020/09/18/2016%EB%85%84/"},{"title":"[1차] 비밀지도","text":"[1차] 비밀지도12345678910111213141516171819202122// https://programmers.co.kr/learn/courses/30/lessons/17681function solution(n, arr1, arr2) { var answer = []; arr1.forEach((element, idx) =&gt; { let c = element | arr2[idx]; let c2 = c.toString(2); let tmp = ''; c2.split('').forEach((val) =&gt; { tmp += Number(val) == '0' ? ' ' : '#'; }); if (tmp.length &lt; n) { tmp = ' '.repeat(n - tmp.length) + tmp; } answer.push(tmp); }); return answer;}result = solution(5, [9, 20, 28, 18, 11], [30, 1, 21, 17, 28]); 해설 정수 배열이 2개 들어온다 각 배열에서 정수를 꺼내 or 연산한다 1, 0을 정해진 문자로 변환한다 2진 변환을 헀는데 자릿수가 작을 수 있다. 그때 앞을 ' '로 채운다","link":"/2020/09/18/1%EC%B0%A8-%EB%B9%84%EB%B0%80%EC%A7%80%EB%8F%84/"},{"title":"DB 시작할 때 쓰는 명령어","text":"terminal1mariadb sql12345678910-- 'webtest'라는 이름의 db 생성create database webtest;-- 'sung'이름의 비밀번호는 '1234'인 유저생성 및 권한 주기create user sung@localhost identified by '1234';grant select on webtest._ to sung@localhost identified by '1234';GRANT ALL PRIVILEGES ON _.\\* TO sung@localhost IDENTIFIED BY '1234' WITH GRANT OPTION;-- 수정사항 반영flush privileges;","link":"/2020/11/02/DB-%EC%8B%9C%EC%9E%91%ED%95%A0-%EB%95%8C-%EC%93%B0%EB%8A%94-%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"title":"System.out.println(); 빠르게 치기","text":"sysout ctrl space","link":"/2020/09/28/System-out-println-%EB%B9%A0%EB%A5%B4%EA%B2%8C-%EC%B9%98%EA%B8%B0/"},{"title":"Promise 연습, js 비동기 연습","text":"js1234// 프로미스 병렬처리 ; allawait Promise.all([delay2(1000), delay2(2000)]).then((result) =&gt; { console.log(result.join(' + '));}); 처음에는 익숙해지기 어렵지만, 꿀인 비동기 promise js에는 promise라는게 있다. 비동기 흐름에서 중요하다. 프로미스는 선언과 동시에 실행이된다. 프로미스 결과를 처리하려면 then을 통해 받아 볼 수 있다. async awaitjs12345678async function delay2(ms) { await new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(ms); }, ms); }); return ms;} await 키워드는 async 함수 내에서만 사용가능하다. await 를 통해서 promise가 Fulfilled상태가 되야지만 다음줄의 코드가 실행된다. 병렬처리Promise.racejs123await Promise.race([delay2(1000), delay2(2000)]).then((result) =&gt; { console.log(result);}); 1초뒤에 1000만 반환하는 코드이다. Promise.alljs123await Promise.all([delay2(1000), delay2(2000)]).then((result) =&gt; { console.log(result.join(' + '));}); 2초뒤에 1000 + 2000을 반환하는 코드이다. 요상한 문법js123(async () =&gt; { console.log(await delay2(1000));})();","link":"/2020/10/28/Promise-%EC%97%B0%EC%8A%B5/"},{"title":"TypeDoc 시작하기","text":"https://chinsun9.github.io/TypeDoc-practice/index.html TypeDoc으로 문서 생성하고 깃허브에서 보기! 따라하기 Typescript: generate documentation을 보고 따라하였습니다. TypeDoc 생성하기샘플 코드 작성package.json123456789101112131415161718{ &quot;name&quot;: &quot;typedoc-practice&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.ts&quot;, &quot;scripts&quot;: { &quot;tsc&quot;: &quot;tsc&quot;, &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: { &quot;typedoc&quot;: &quot;^0.19.2&quot;, &quot;typescript&quot;: &quot;^4.0.3&quot;, &quot;typedoc-plugin-nojekyll&quot;: &quot;^1.0.1&quot; }, &quot;dependencies&quot;: {}} 연습용 디렉터리를 생성하고 위 내용으로 package.json을 생성한다. cmd1npm i 종속성을 설치한다. tsconfig.json123456789101112131415{ &quot;compilerOptions&quot;: { &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: { &quot;*&quot;: [&quot;types/*&quot;] }, &quot;target&quot;: &quot;ES3&quot;, &quot;module&quot;: &quot;commonjs&quot;, &quot;sourceMap&quot;: true, &quot;resolveJsonModule&quot;: true, &quot;esModuleInterop&quot;: true }, &quot;typedocOptions&quot;: { &quot;mode&quot;: &quot;modules&quot;, &quot;out&quot;: &quot;docs&quot; }} 타입스크립트 설정파일 tsconfig.json를 생성한다. index.ts1234567891011121314151617181920212223242526272829303132333435363738/** * This class keeps track of the version number * of your application. */class Status { /** * This property ... */ public version: number = 0; /** * This method prints out the current version number */ public showVersion() { console.log('version:', this.version); } /** * This method increases the version number with 1 * * @returns the current version number */ public increaseVersion() { this.version += 1; return this.version; } /** * change the version number to the provided number * * @param version the number that needs to be used as a version number * @returns the current version number */ public changeVersion(version: number) { this.version = version; return this.version; }} index.ts를 생성하고, 독주석을 작성한다. 나는 Typescript: generate documentation를 참고하여 작성하였다. javaDoc과 동일한 문법으로 작성하면된다. 독주석을 작성하고싶은 클래스나 메소드, 변수 위에 /**를 타입하면 독주석 자동완성이 나온다. 자동완성으로 만들경우에 @param, @returns가 자동완성된다. typedoc 생성하기 이제 문서를 생성해보자 cmd1npx typedoc --out docs docs라는 폴더가 생긴다. docs/index.html 파일을 열어서 잘 만들어졌는지 확인한다. 이제 깃허브에서 볼 수 있도록 해보자. 깃허브에 올리기 처음 package.json에 보면 typedoc-plugin-nojekyll 모듈을 설치해줬는데, 기본적으로 깃허브 페이지는 지킬 기반으로 동작한다. 지킬에는 어떤 규칙이 있는데 _로 시작하면 페이지가 안나온다. typedoc을 통해 생성된 html은 _index_.html 이런식으로 _가 붙는다. 따라서 docs/ 디렉터리에 지킬을 사용하지 않는다는 것을 알리는 .nojekyll이라는 파일을 만들어놔야한다. 수동으로 .nojekyll을 추가할 수 있지만, npx typedoc --out docs명령을 쓸때마다 초기화되서 불편하다. typedoc-plugin-nojekyll 모듈은 이 문제를 해결해준다. .gitignore 추가.gitignore123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113# Created by https://www.toptal.com/developers/gitignore/api/node# Edit at https://www.toptal.com/developers/gitignore?templates=node### Node #### Logslogs*.lognpm-debug.log*yarn-debug.log*yarn-error.log*lerna-debug.log*# Diagnostic reports (https://nodejs.org/api/report.html)report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json# Runtime datapids*.pid*.seed*.pid.lock# Directory for instrumented libs generated by jscoverage/JSCoverlib-cov# Coverage directory used by tools like istanbulcoverage*.lcov# nyc test coverage.nyc_output# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files).grunt# Bower dependency directory (https://bower.io/)bower_components# node-waf configuration.lock-wscript# Compiled binary addons (https://nodejs.org/api/addons.html)build/Release# Dependency directoriesnode_modules/jspm_packages/# TypeScript v1 declaration filestypings/# TypeScript cache*.tsbuildinfo# Optional npm cache directory.npm# Optional eslint cache.eslintcache# Microbundle cache.rpt2_cache/.rts2_cache_cjs/.rts2_cache_es/.rts2_cache_umd/# Optional REPL history.node_repl_history# Output of 'npm pack'*.tgz# Yarn Integrity file.yarn-integrity# dotenv environment variables file.env.env.test# parcel-bundler cache (https://parceljs.org/).cache# Next.js build output.next# Nuxt.js build / generate output.nuxtdist# Gatsby files.cache/# Comment in the public line in if your project uses Gatsby and not Next.js# https://nextjs.org/blog/next-9-1#public-directory-support# public# vuepress build output.vuepress/dist# Serverless directories.serverless/# FuseBox cache.fusebox/# DynamoDB Local files.dynamodb/# TernJS port file.tern-port# Stores VSCode versions used for testing VSCode extensions.vscode-test# End of https://www.toptal.com/developers/gitignore/api/node .gitignore 파일을 만든다. node프로젝트용 무시목록이다. 깃허브에 저장소를 만들고 푸쉬한다. 저장소 &gt; 세팅 master, docs 선택하고 save버튼을 누른다. 생성된 링크를 클릭해서 잘 동작하는지 확인한다. 여기까지 소스코드","link":"/2020/09/24/TypeDoc-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"a tag no color","text":"css1234567a { color: inherit;}a:hover { color: blue;} a tag는 보통 파란색으로 표시되고, 해당링크에 방문한적이 있으면 색이 달라진다. 아이콘 같은 곳에 링크를 걸었을때 이러한 특징으로 인해 약간 보기싫어지는 경우가 있는데 이를 해결할 수 있다.","link":"/2020/10/08/a-tag-no-color/"},{"title":"aws ec2 docker 설치","text":"docker 실행 명령어 sudo service docker start// docker 실행 참고 https://docs.aws.amazon.com/ko_kr/AmazonECS/latest/developerguide/docker-basics.html","link":"/2020/10/16/aws-ec2-docker/"},{"title":"RDS 비공개하는 방법","text":"내 RDS 지키기 내가 지정한 IP에서만 접근가능하도록 설정하자 따라하기 설정하고싶은 RDS 화면에 들어간다 연결 &amp; 보안 &gt; 보안 &gt; vpc 보안 그룹 을 눌러서 현재 rds에 적용되어 있는 보안그룹 설정으로 들어간다. 인바운드 규칙 &gt; 인바운드 규칙 편집으로 들어간다 아마 이런식으로 위치무관으로 되어있을 수 있는데 이 규칙으로 인해 모든 컴퓨터에서 접근가능하게 해준다. 이 규칙을 이제 내 컴퓨터에서만 접근가능하도록 고쳐보자. MySQL/Aurora 를 선택해서 포트를 제한한다 소스 유형에 내 IP 를 선택한다 내 공인 IP 주소로 바뀌었는지 확인한다. 이렇게하면 내 IP에서 MySQL 접근 포트인 3306 포트로만 접근을 허용하는 세팅이 된 것이다. 규칙 저장을 눌러 적용시켜준다. 끝!","link":"/2020/09/22/RDS-%EB%B9%84%EA%B3%B5%EA%B0%9C%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/"},{"title":"윈도우에서 aws ec2 keypair 설정","text":"윈도우 10에서 aws ec2를 리모트할 때 .pem파일의 권한을 아무나 볼 수 없게 설정해줘야 한다. 관리자만 볼 수 있도록 설정해야 리모트를 할 수 있다. 속성 &gt; 보안탭 &gt; 고급 &gt; 상속사용안함 &gt; 명시적 사용 권한 &gt; SYSTEM, Administrators 남기고 다 삭제 &gt; 확인 &gt; 확인 SYSTEM, Administrators만 남은걸 확인한다","link":"/2020/10/26/aws-ec2-keypair-%EC%84%A4%EC%A0%95/"},{"title":"aws 아마존 리눅스2 인스턴스 생성 및 리모트","text":"ec2 인스턴스를 하나 만들고, vscode로 원격접속해보겠다. 따라하기준비물 ec2 keypair vscode ec2 인스턴스 생성하기 예전에는 인스턴스 하나 생성하는 것도 겁이 났었는데, 지금은 옵션 안보고 그냥 기본값으로 생성.. ec2 인스턴스 리모트하기 ssh 클라이언트로 푸티 putty가 대표적이다 근데 나는 푸티는 잘 안쓰고… vscode의 Remote - SSH 확장도구를 사용한다. vscode를 관리자권한으로 실행한다. (열려있는 vscode가 있다면 모두 종료하고 관리자 권한으로 새로 실행한다) Ctrl + Shift + P 를 눌러 커맨드창을 열고 remote를 입력하고, Remete-SSH: Connect to Host... 를 누른다 .ssh\\config12345# Read more about SSH config files: https://linux.die.net/man/5/ssh_configHost ec2-asdf HostName ec2-0-00-000-000.ap-northeast-2.compute.amazonaws.com User ec2-user IdentityFile &quot;C:\\key\\KeyPair.pem&quot; config 파일을 채워줘야하는데, 브라우저로 ec2 인스턴스 화면으로 돌아가서 우클릭 연결을 누른다 위 화면에서 복사를 해서 붙여넣어주면된다. HostName에 ec2-0-00-000-000.ap-northeast-2.compute.amazonaws.com User에 @앞에 있는 유저명을 적어주면된다. 나는 ec2-user가 기본값이 였다 Host에는 그냥 자기가 원하는 식별문자를 적어주면된다. 나는 아무렇게나 ec2-asdf로 했다. IdentityFile에는 키페어 .pem 파일의 경로를 적어주면된다. 절대경로를 사용했다 Ctrl + S 로 저장한다. 참고 : HostNameec2-0-00-000-000.ap-northeast-2.compute.amazonaws.com 이 값은 인스턴스를 중지했다가 다시켜면 바뀐다. 다음번에 접속할 때 탄력적 IP를 사용하는게 아니라면 계속 수정하면서 접속해야한다. Ctrl + Shift + P 를 눌러 커맨드창을 열고 Remote-SSH: Connect to Host를 실행하고 방금 설정한 호스트가 보일 것이다. 클릭한다 그러면 새창이 열린다. 참고 : keypair 권한 관련 오류가 나면 윈도우에서 aws ec2 keypair 설정를 확인한다 123456[14:56:31.053] &gt; @ WARNING: UNPROTECTED PRIVATE KEY FILE! @&gt; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&gt; Permissions for 'C:\\\\key\\\\KeyPair.pem' are too open.&gt; It is required that your private key files are NOT accessible by others.&gt; This private key will be ignored.&gt; Load key &quot;C:\\\\key\\\\a.pem&quot;: bad permissions 운영체제를 고르라고하는데 당연히 리눅스를 선택한다. 이렇게 vscode로 리모트에 성공했다. 폴더를 열어보자. 나는 홈디렉터리를 열어보겠다. 그러면 창이 리로드 되면서 좌측 탐색기가 업데이트된다. terminal123mkdir a b cls mkdir 로 a,b,c 3개의 디렉터리를 생성한다 그러면 좌측 탐색기도 업데이트되는게 보일 것이다. 끝!","link":"/2020/10/26/aws-%EC%95%84%EB%A7%88%EC%A1%B4-%EB%A6%AC%EB%88%85%EC%8A%A42-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%83%9D%EC%84%B1-%EB%B0%8F-%EB%A6%AC%EB%AA%A8%ED%8A%B8/"},{"title":"about 페이지 만드는 방법","text":"기본적으로 about 페이지가 없다! 근데 상단 네비게이션바에는 About 링크가 있다! About 페이지가 필요없으면 상단 네비게이션바에서 링크를 없애도 되는데, 나는 만들어 보았다. 만드는 법hexo new page &quot;about&quot; 위 명령을 치면 source/about/index.md 이 자동생성된다. index.md를 열고 열심히 수정하면 끝","link":"/2020/09/17/about-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B0%A9%EB%B2%95/"},{"title":"awesome button css","text":"Button With Awesome Hover Effects using Html CSS &amp; jQuery | mouseenter and mouseout events 위 영상을 보고 따라 만들었다. 영상에서는 제이쿼리를 사용해서 구현하지만, 나는 제이쿼리없이 구현해보았다. 결과 참고 ; 소스코드","link":"/2020/11/02/awesome-button-css/"},{"title":"aws 카테고리 생성","text":"aws 공부한 내용 올리기","link":"/2020/09/18/aws-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC-%EC%83%9D%EC%84%B1/"},{"title":"cmd로 프로세스 죽이기","text":"cmd123taskkill /IM &quot;process name&quot; /Ftaskkill /IM &quot;oCam.exe&quot; /F 나는 주로 정상 종료할 때 광고 뜨는 프로그램을 종료하거나, 한번에 여러 프로그램을 종료하려고 배치파일로 만들어 사용했다. 실행해도 안꺼지는 경우, 관리자 권한이 필요할 수도있다.","link":"/2020/10/19/cmd-kill-process/"},{"title":"cmd 관리자 권한","text":"관리자 권한으로 배치파일을 실행했을때 경로가 바뀌는 것을 해결할 수 있다. pushd “%~dp0”1pushd &quot;%~dp0&quot; 위 명령은 .bat 파일이 있는 경로로 자동 cd해주는 명령이다. 보통 .bat 파일을 만들때 관리자 권한이 필요한 명령이 있을 수 있다. .bat을 기준하여 상대경로로 멋지게 로직을 쫘놨는데.. 관리자 권한으로 실행하면 제멋대로 C:\\WINDOWS\\system32 경로로 실행해버리는 바람에 원하는 결과가 나오지 않는다. 위 명령으로 해결!","link":"/2020/10/06/cmd-%EA%B4%80%EB%A6%AC%EC%9E%90-%EA%B6%8C%ED%95%9C/"},{"title":"cmd 이전 내용 지우기 cls","text":"cmd1cls linux terminal는 clear","link":"/2020/09/21/cmd-%EC%9D%B4%EC%A0%84-%EB%82%B4%EC%9A%A9-%EC%A7%80%EC%9A%B0%EA%B8%B0-cls/"},{"title":"cmd 폴더 삭제 rmdir","text":"cmd12345rmdir /s {디렉터리}rmdir /s folder_namermdir /s folder1_name folder2_name rmdir /s {디렉터리} /s 옵션으로 빈 디렉터리가 아니더라도 삭제할 수 있다. 디렉터리를 나열해서 여러개를 한번에 지울 수 있다 auto yes 지울때 y를 입력해줘야하는데.. cmd123echo y|rmdir /s folder1_nameecho yy|rmdir /s folder1_name folder2_name 이런식으로 사용하면 자동 수락한다 약간 귀찮긴하다.. 그냥 여러 파일, 폴더 삭제는 탐색기 열어서 하는게 빠름..","link":"/2020/10/21/cmd-%ED%8F%B4%EB%8D%94-%EC%82%AD%EC%A0%9C-rmdir/"},{"title":"CRLF, LF","text":"LF\\n CRLF = CR + LF\\r\\n 여러줄의 텍스트를 가진 file을 읽고 처리할 때 줄바꿈 형식을 알고 있어야한다. 윈도우의 경우 CRLF이다. vscode에서 쉽게 변환하기 vscode에서는 우측하단에 보면, 인코딩 형식과 줄바꿈 형식을 알려준다. 우측하단을 클릭해서 변환할 수 있다. 또는 ctrl + shift + p 에서 end of line을 검색해서 변환할 수 있다.","link":"/2020/11/09/crlf-lf/"},{"title":"connection vs connection pool","text":"connection pool를 써보자 Connection pool 기존 connection은 데이터베이스에 동시 접속 허용량을 초과하는 연결을 할 경우 에러 발생 connection pool을 사용하면 대기상태가 되었다가 수행됨 pool 에 여러 미리 생성되어 있는 connection을 가져가 쓴다 connection이 미리 생성되어있기 때문에 생성시간 소모되지 않음. 따라서 속도 빨라짐. 쉽게 다운되지 않음. 참고 Database Tutorial – Single Connection vs Connection Pool [DB]Connection Pool","link":"/2020/11/10/conn/"},{"title":"cmd 폴더 생성","text":"cmd123mkdir new-foldermkdir a\\b\\c mkdir [폴더명]","link":"/2020/09/21/cmd-%ED%8F%B4%EB%8D%94-%EC%83%9D%EC%84%B1/"},{"title":"disqus로 블로그 댓글 사용하기","text":"hexo icarus theme 에서는 disqus를 기본으로 지원한다. 우리는 disqus에서 shortname을 알아내서 적어주기만 하면 된다. 너무 간편하다! 따라하기 hexo icarus theme 기준입니다! 스샷아래 설명이 있는데 그냥 스샷 그대로 따라가면 됩니다. DISQUS 회원가입 DISQUS에 회원가입하고 로그인한다. DISQUS에서 사이트 추가(Shortname만들고 확인하기) GET STARTED 버튼 클릭 I want to install Disqus on my site 버튼 클릭 항목 작성 스크롤을 내려서 Basic 선택 스크롤을 내려서 ...with Universal Code 선택 뭐라뭐라 막 나오는데, 다 무시하고 스크롤을 내려서 Configure 버튼 클릭 Website URL 항목만 채우고 Complete Setup 버튼 클릭 하단 Dismiss Setup 버튼을 클릭하고, 상단에 Edit Settings 버튼 클릭 Shortname 항목에서 내 Shortname을 확인하고 복사한다. _config.icarus.yml에 Shortname 설정하기 _config.icarus.yml1234comment: type: disqus # Disqus shortname shortname: 'chinsun9' 이렇게 설정해주면 끝..! 놀랍게도 적용이 완료되었다!","link":"/2020/09/23/disqus%EB%A1%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%8C%93%EA%B8%80-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"title":"cmd에서 새 파일 생성 명령어 copy con","text":"cmd1copy con new_file.txt windows에서 새 파일을 cli로 만들고 싶을 때… copy con new_file.txt를 치면 바로 생성되지 않고 파일의 내용을 입력할 수 있다. Ctrl + Z 키를 눌러 작성을 완료하면 된다. 아무것도 작성하지 않으면 빈 파일을 생성할 수 있다.","link":"/2020/10/14/copy-con-name-txt/"},{"title":"ec2 web app https 적용하기","text":"웹에서 위치정보를 활용하고 싶어서 geolocation을 사용했는데, geolocation은 localhost 또는 https에서만 동작했다. 위치정보를 활용하는 이 앱을 다른사람들에게 배포하기 위해서는 https를 사용했어야 했다. 삽질을 많이했는데, 어떻게 하는지 정리한다. 할게 쫌 많고, 중간중간 대기시간이 길다. 처음부터 끝까지 무료로 하는 법이다 따라하면 ec2에서 express로 돌아가는 웹앱에 https를 적용할 수 있다. 내가 시도한 환경 aws 프리티어 ec2 (아마존 리눅스 2) 탄력적 IP 주의사항 ; 탄력적 IP는 1개까지 무료다. 탄력적 IP를 사용하면 연결된 ec2 인스턴스를 종료해서는 안된다. 인스턴스는 매월 750시간 무료다. 이 인스턴스를 제외하고 다른 인스턴스를 실행하면 비용이 생길 수 있다. 해야할일 목록… express 웹 앱준비. ec2 보안그룹 인바운드 설정 (http, https, 앱에서 사용하는 포트 열기) ec2에 탄력적 IP 할당 ACM(AWS Certificate Manager)에서 SSL/TLS 인증서 발급요청 freenom에서 도메인 얻기 cloudflare 가입하고 사이트 추가 freenom dns 설정 및 SSL/TLS 인증서 발급 완료 freenom에서 cloudflare로 네임서버 변경 aws 애플리케이션 로드 밸런서 생성 cloudflare dns 설정 따라하기express 웹 앱 준비.terminal123express https-web-app --view=ejscd https-web-appnpm i 간단하게 익스프레스 제너레이터로 웹앱을 생성한다. 새로 생성하거나 기존에 있는 웹앱을 ec2 인스턴스에 올려준다. terminal1export PORT=8080&amp;&amp; node ./bin/www 앱을 실행한다. 나는 익스프레스 제너레이터로 만들었기때문에 process.env.PORT로 8080값을 줘서 8080포트로 앱이 실행되도록하였다. ec2에 탄력적 IP 할당 ec2 &gt; 탄력적 IP 주소 &gt; 탄력적 IP 주소 할당 방금 앱을 실행한 인스턴스를 선택하고 할당해준다. 주의 : 탄력적 IP를 할당한 이상 연결된 EC2가 종료되어 탄력적 IP에 아무것도 연결되어 있지 않으면 비용이 발생한다. 또, 탄력적 IP는 1개까지 무료이다. EC2도 이제부터 매일 돌아가게됨(750시간 무료)으로 사실상 실행할 수 있는 인스턴스는 1개로 제한된다. ec2 보안그룹 인바운드 설정 (http, https, 앱에서 사용하는 포트 열기) 앱이 실행되고있는 ec2 인스턴스 보안그룹으로 들어가 인바운드 규칙을 편집한다. http와 https를 어디서나 접근가능하게 한다. 또 앱을 실행 포트도 어디선 접근가능하게 한다. 나의 경우 8080포트이다. freenom에서 도메인 얻기 내가 도메인을 얻을 때 이사이트가 엄청나게 느리기때문에 많은 인내가 필요하다.. 수시로 404 not found가 뜬다… 새로고침을 몇번했는지 모르곘다. freenom에서 나는 처음 도메인을 얻어봤다. 그런데 여기서 삽질한 것이 당연히 회원가입을 먼저하고 도메인을 얻는 것인줄 알았으나, 도메인을 얻는 과정에서 체크아웃을 하면서 회원가입을 진행해야 정상 진행된다. 원하는 도메인을 입력한다. FREE 라벨이 붙은것중에서 원하는 것을 선택한다. 원하는 도메인을 선택하면, 체크아웃 버튼이 생긴다. 체크아웃버튼을 눌러준다. 기간을 선택하고 Continue버튼을 누른다. 여기서 드디어 회원가입을 진행한다.. 나는 왼쪽 이메일 인증을 선택하였다. 이메일 입력하고 버튼을 누르면, 해당 메일로 인증 url이 날라오는데 클릭해서 다음을 진행한다. 이렇게 회원가입폼이 나오는데 빨간부분을 채워주고 동의체크하고 완료한다. 이렇게 무료로 도메인 얻기에 성공했다. 이제 aws로 돌아와서 무료로 인증서를 발급받아보자. ACM(AWS Certificate Manager)에서 SSL/TLS 인증서 발급요청 ACM(AWS Certificate Manager)에서 인증서 요청 &gt; 공인 인증서 요청 으로 들어간다 도메인 이름을 추가한다. 나는 이 인증서에 다른 이름 추가 버튼을 통해 *.domainname 도 추가해줬다. 검증 방법으로 DNS 검증을 선택한다 다음 검토 화면은 그냥 확인 마지막 단계 검증 화면에서 조금 기다리면 이런 화면이 나온다. 도메인 이름 옆에 펼치기 버튼을 클릭해주면 이름 유형 값이라는 게 나오는데 이 값들을 freenom dns 설정에서 레코드로 추가해줄 것이다. freenom dns 설정 및 SSL/TLS 인증서 발급 완료 freenom 사이트로 돌아와서 로그인하고 상단 메뉴에 Services &gt; My domains 클릭 Manage Domain 버튼을 클릭하고 Manage Freenom DNS를 클릭한다. 위같은 화면이 나오면 아까 ACM에서 봤던 이름과 값들을 채워준다. 주의 : 타입을 CNAME으로 한다. 위와같이 매칭시켜주면된다. 나는 *.domainname으로 추가 이름을 지정해줬는데 이 경우에는 이름과 값이 완전히 똑같기 때문에 한개의 레코드만 설정해주면된다. *이 아니고, www. 같은 이름을 추가한 경우에는 레코드를 하나 더 추가하고 똑같이 매칭시켜서 입력해주면 된다. 저장한다 이제 ACM으로 돌아와서 인증서 상태가 발급 완료로 변할때까지 기다리면서 유튜브 한편을 보고온다. 나는 약 5-10분정도 기다린 것 같다. 만약에 20분이 넘도록 검증 보류 상태라면 뭔가 잘못 따라한 것이다. 이제 DNS 네임서버를 cloudflare로 바꿀 것이다. cloudflare 가입하고 사이트 추가 회원가입한다. 회원가입을 완료하면, 사이트를 추가할 수 있는데, 내 도메인을 입력한다. 다음화면에서 Free를 선택하고 넘어간다 넘어오면 이렇게 스캔하는 화면이 나온다. 스캔이 완료되면 이런화면이 나오는데, 비어있다면, 아까 freenom에서 dns 설정한것처럼 똑같이 타입을 cname으로 하여 이름, 값을 넣어준다. 완료했다면 다음화면을 넘어간다. 그러면 네임 서버를 바꾸라는 말이 나온다. 이제 freenom사이트로 돌아가서 네임서버를 변경해보자. freenom에서 cloudflare로 네임서버 변경 상단 메뉴에 Services &gt; My domains 클릭 Manage Domain 버튼을 클릭하고 Management Tools &gt; Nameservers를 클릭한다. 네임 서버를 변경해준다. 성공하면, cloudflare화면으로 돌아와서 완료를 눌러준다. 이런화면이 나오는데 나는 항상 https 옵션을 켜주고 완료해주었다. 해당 사이트의 개요화면으로 넘어가는데 만약에 이런화면이 나오는데 1~5분정도 기다리면, 이런 화면으로 바뀐다. 이제 aws로 돌아와 로드 밸런서를 생성해줄 것이다. aws 애플리케이션 로드 밸런서 생성 ec2 &gt; 로드 밸런서 &gt; 로드 밸런서 생성 &gt; 애플리케이션 로드 밸런서 생성 이름을 정해주고, 리스너에서 https를 추가해준다. 가용영역 체크하고 다음으로 넘어간다. 발급받은 도메인 인증서를 선택하고 다음으로 넘어간다. ce2 인스턴스가 속해있는 보안그룹을 선택한다. 적당히 이름을 짓고, 포트에서 내 앱이 사용하고있는 포트를 입력하고 다음으로 넘어간다. 내 앱이 실행되고있는 인스턴스를 선택하고 등록된 항목에 추가 버튼을 누른다. 그러면 3이라고 표시한 주황색 박스에 해당 인스턴스가 추가되는 걸 확인할 수 있다. 검토화면에서 다음버튼 로드밸런서 메인화면으로 넘어와지면 생성된 로드밸런서의 DNS이름을 복사한다. 이제 cloudflare dns 설정만 하면 끝이다! cloudflare dns 설정 cloudflare에 와서 위처럼 새로운 레코드를 추가하고 타입은 CNAME, 이름은 @, 대상은 방금 복사한 로드밸런서 DNS이름을 넣어주고 저장을 누르면 완료다. 끝 이제 자신의 도메인으로 접속을 해보면…. https..! 여기서 잠깐..! 처음에 npm start로 웹 앱을 실행시켰는데 이러면 ec2 리모트를 종료하는 순간 앱도 같이 종료된다. nohup export PORT=8080&amp;&amp; node ./bin/www &amp; 이런식으로 실행해야 ec2 리모트를 종료해도 웹 앱이 계속 살아 있다. 참고 ; linux node app 백그라운드 실행 참고 https://youtu.be/dMVy3BQB314","link":"/2020/10/30/ec2-web-app-https-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"title":"etc 카테고리 생성","text":"잡다한 소리를 하는 곳입니다.","link":"/2020/09/17/etc-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC-%EC%83%9D%EC%84%B1/"},{"title":"css !important","text":"example123div { color: blue !important;} 무적기… 근데 권장하진 않는다!","link":"/2020/09/18/css-important/"},{"title":"denied: requested access to the resource is denied","text":"denied: requested access to the resource is denied docker hub에 내가 연습했던 이미지를 업로드하려고 했는데 실패했다. 이미지명 변경cmd123docker image tag {이미지} {내 유저명}/{이미지}docker image tag my-react:0.0.1 chinsung/my-react:0.0.1 이런식으로 {내 유저명}/을 붙여주면 된다. 음 성공! 참고한 곳 ; [Docker CE] 도커 이미지 업로드 권한 에러 (denied: requested access to the resource is denied)","link":"/2020/10/22/denied-requested-access-to-the-resource-is-denied/"},{"title":"favicon이 안나오는 문제","text":"- 로컬에서는 분명히 잘나오는데.. 깃허브에 배포만 하면 파비콘이 사라진다?? 해결하기1234head: # URL or path to the website's icon favicon: /img/favicon.png? # Open Graph metadata _config.icarus.yml 에서 상단에 favicon을 설정하는 부분이 있다. 맨 끝에 ?를 추가한다. 끝! 이러면 깃허브 페이지에서도 favicon이 잘 나온다. 참고","link":"/2020/09/17/favicon%EC%9D%B4-%EC%95%88%EB%82%98%EC%98%A4%EB%8A%94-%EB%AC%B8%EC%A0%9C/"},{"title":"fetch api 연습","text":"12345678910fetch('http://localhost:3000/users') .then(function (response) { return response.json(); }) .then(function (myJson) { console.log(JSON.stringify(myJson)); }) .catch(function (error) { console.log(error); }); https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch fetch api 써먹기users router12345let users = [];app.get('/users', (req, res) =&gt; { return res.json(users);}); fetch api1234567891011121314151617181920212223242526272829303132333435function getUserList() { // listbox 초기화 let newListbox = document.createElement('li'); newListbox.innerHTML = `&lt;li class=&quot;list-group-item head&quot;&gt;User List&lt;/li&gt;`; const url = '/users'; const fetchResponsePromise = fetch(url); fetchResponsePromise .then((response) =&gt; { if (response.status === 200) { return response.json(); } else { throw new Error('Something went wrong on api server!'); } }) .then((response) =&gt; { console.log(`fetch`, response); let i = 0; for (const key in response) { i++; if (response.hasOwnProperty(key)) { const element = response[key]; const new_li_element = document.createElement('li'); new_li_element.className = 'list-group-item'; new_li_element.appendChild(document.createTextNode(element)); newListbox.appendChild(new_li_element); } } listbox.innerHTML = newListbox.innerHTML; }) .catch((error) =&gt; { console.error(error); });} users라는 라우터에서는 유저배열을 반환한다. 유저배열을 json으로 받는데, 그걸 받아서 화면에서 유저목록을 갱신한다. 나는 ajax하면 xhr객체를 만들어서 가져오곤 했는데 이번에는 fetch를 사용해 보았다. fetch가 간단하고 간결한 것 같다. 이 코드가 들어 있는 프로젝트 : Chat App (NodeJs &amp; Socket.IO )","link":"/2020/10/28/fetch-%EC%97%B0%EC%8A%B5/"},{"title":"github api로 특정 저장소의 커밋내역 불러오기","text":"깃허브 api로 특정 저장소 커밋내역 json으로 받아보기 나는 내 special repository인 chinsun9 저장소의 커밋내역을 받아와보았다. github api https://api.github.com/repos/chinsun9/chinsun9/commitshttps://api.github.com/repos/{유저명}/{저장소명}/commits js에서는 fetch api로 데이터를 가져와 원하는 로직을 수행하면 될 것 같다. github api가 있다는 것을 알아보았고, 맛보기를 해보았다. 비공개 저장소 접근이나 다른 유용한 api가 있는지 알아보고 활용하면 좋을 것 같다.","link":"/2020/11/02/github-api%EB%A1%9C-%ED%8A%B9%EC%A0%95-%EC%A0%80%EC%9E%A5%EC%86%8C%EC%9D%98-%EC%BB%A4%EB%B0%8B%EB%82%B4%EC%97%AD-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0/"},{"title":"git push -f","text":"1git push -f 바로 직전 커밋 취소를 했는데 푸쉬하니가 멀쥐가 되었다…? git push -f -f, --force옵션은 푸쉬하는데 원격 저장소를 아예 덮어쓰는 옵션이다. 따라서 이미 원격 저장소에 올렸는데 커밋을 수정한 경우에 사용할 수 있다.","link":"/2020/10/19/git-push-f/"},{"title":".gitignore 써서 커밋 가볍게 하기","text":"깔끔하게 코드 공유하기, 숨겨야하는 파일 숨기기! 따라하기준비물 깃허브 데스크탑 이클립스 (java IDE) 샘플 자바 프로젝트 만들기 이런 구조의 자바 프로젝트가 있다..├── .settings│ └── org.eclipse.jdt.core.prefs├── bin│ ├── HelloWorld.class│ └── Tmp.class├── src│ ├── HelloWorld.java│ └── Tmp.java├── .gitignore├── .classpath└── .project .java 파일은 컴파일 과정을 통해 .class 파일이 된다. 코드를 공유할때 java파일만 있어도 충분히 공유 받은 사람이 컴파일해서 사용할 수 있다. .class 파일은 공유할 필요가 없는 것이다. .gitignore 파일이 빈파일이라고 하면 총 8개의 파일이 트랙된다. .gitignore에 *.class추가하기.gitignore1*.class .gitignore 에 위 내용을 추가하면 이렇게 .class 파일이 빠지고 6개 파일만 트랙된다. 이렇게해서 내 로컬에는 남아있지만 깃에서는 무시된다. 깃허브 데스크탑에서 gitignore 파일 추가하기 Tmp.java는 내가 혼자 막 테스트하느라 임시로 생성한 파일이라고 해보자. 다른사람이 봐도 아무 의미가 없는 파일이라면 .gitignore에 추가해준다. 깃허브 데스크탑에서 우클릭으로 무시 목록에 추가해보았다. 그러면 이렇게 자동으로 .gitignore이 업데이트 된다. 이렇게 Tmp.java가 무시되어 5개만 트랙되는 모습니다. 이런식으로 특정 파일을 골라서 무시할 수 있다. 이제 init이라는 커밋 하나를 해보겠다. 이미 커밋한 파일 gitignore하기 HelloWolrd.java를 수정했다. 근데 HelloWolrd.java도 .gitignore에 추가해야할 거 같아서 Tmp.java와 같은 방법으로 무시하기를 했는데… .gitignore에 분명이 추가되었지만 여전히 트랙되고있다… 이미 한번 커밋된적이 있는 파일들을 새로이 .gitignore에 추가했을때 생기는 문제다. 이럴 때는 터미널에 git rm -r --cached .명령을 통해 캐시를 삭제하고.. cmd1git rm -r --cached . 깃허브 데스크탑으로 돌아와보면 이렇게 제외되있는걸 확인할 수 있다. 초록색 + 표시는 무시해도된다. 이미 커밋되었지만 캐시가 삭제되서 다시 나타난 거다. 여기까지 커밋 내역팁 이렇게 하나씩 수동으로 무시할 파일을 지정하는 방법이 있지만 프로젝트 구조가 비슷하기 때문에 사람들이 미리 정의해둔 .gitignore을 쓰면 편리하다. 깃허브 데스크탑에서 로컬 저장소를 생성할때 gitignore을 설정하는데 그렇게 쓰는 방법도 있고, https://www.toptal.com/developers/gitignore 여기서 자신이 어떤 언어를 쓰는지, 어떤 IDE를 쓰는지에 따라서 자동 생성해준다.","link":"/2020/09/24/gitignore-%EC%8D%A8%EC%84%9C-%EC%BB%A4%EB%B0%8B-%EA%B0%80%EB%B3%8D%EA%B2%8C-%ED%95%98%EA%B8%B020200924/"},{"title":"git 카테고리 생성","text":"git, github 공부한 내용 올리기","link":"/2020/09/18/github-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC-%EC%83%9D%EC%84%B1/"},{"title":"github.io 저장소에 readme.md 만들기","text":"- 더이상 github.io 저장소가 허전하지 않게 되었다! source/readme.md 생성 _config.yml 에서 skip_render에 readme 추가1234i18n_dir: ':lang'skip_render: - readme.mdnew_post_name: ':title:year:month:day.md' 의문 skip_render에 추가했는데 어째서인지 readme.html이 자동생성된다.. gitignore에도 추가해 보았는데 무시가 안된다 참고","link":"/2020/09/17/github-io-%EC%A0%80%EC%9E%A5%EC%86%8C%EC%97%90-readme-md-%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"title":"gradle project 에서 runnable jar 생성하기","text":"일반 자바 프로젝트 처럼 Export &gt; Runnable JAR file로 jar을 만들게 되면 생성된 jar파일의 용량이 매우 작은것을 확인할 수 있다. 내가 추가한 외부 라이브러리들이 전부 빠져서 동작하지 않는다 gradle project에서는 어떤방식으로 runable jar을 만들어야 할까? build.gradle 수정하기build.gradle12345678910jar { manifest { attributes 'Main-Class': 'tmp.gradle.project.Main' } from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } }} jar { … } 에 해당하는 부분을 위처럼 새로이 추가해준다. attributes 'Main-Class': 'tmp.gradle.project.Main' 여기에는 자신의 메인 클래스를 지정하면된다. jar파일 생성하기 terminal12cd {gradle project rootpath}gradle jar 자신의 그래들 프로젝트 경로에서 cmd를 켜주고 gradle jar 명령을 실행한다. jar파일 확인하기 build/libs 디렉터리에 가보면 jar파일이 생성되있음을 확인할 수 있다. terminal12cd build\\libsjava -jar {jar파일명} 로 한번 잘 실행되는지 확인한다.","link":"/2020/11/06/gradle-project-%EC%97%90%EC%84%9C-runnable-jar-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0/"},{"title":"이클립스에서 gradle 프로젝트 생성하기","text":"나는 C &gt; C++ &gt; java &gt; js 순으로 배웠다 요즘은 쭉 nodejs에서 npm, package.json 을 통해 모듈을 쉽게 설치하고 관리하였다 오랜만에 java로 돌아오니까 외부 라이브러리를 임포트할 때 불편하게 느껴졌다 gradle의 이론이 대해서는 자세히 모르지만, 이전에 build.gradle파일을 통해 라이브러리를 설치한 기억이 있어서 gradle 프로젝트를 생성, 사용해보았다 gradle 설치 Windows에 Gradle 설치하기 by Jeongjin Kim 를 보고 따라했다. https://gradle.org/releases/ 에 들어가서 garadle을 다운 받는다. Download: binary-only or complete 인데 나는 binary-only 를 다운받았다. .zip 파일로 받아지는데 적당한 위치에 압축을 풀어주고 환경변수를 세팅한다. GRADLE_HOME : 그래들 디렉터리 경로 ex) C:\\Tools\\gradle-6.6.1 path : %GRADLE_HOME%\\bin 새롭게 cmd를 열고 gradle -v하여 잘 설치되었는지 확인한다. 이클립스에 gradle 플러그인 설치 및 세팅 Gradle Beginner Tutorial 4 | How to create Gradle Project in Eclipse from Scratch | Windows &amp; Mac 을 보고 따라했다. 여기서는 맥, 윈도우 모두 알려주기때문에 뛰엄뛰엄 봐야한다. Help &gt; Marketplace 로 들어가 gradle을 검색한다. 코끼리 모양의 아이콘을 가진 Buildship Gradle Integration 3.0 을 인스톨했다. 이클립스 재시작 Window &gt; Preferences 로 들어간다. gradle을 검색하고 gradle 경로를 지정해준다. 여기서 C:\\Tools\\gradle-6.6.1 환경변수 설정에서 GRADLE_HOME으로 지정했던 경로를 적어준다. 이제 그래들 프로젝트를 생성해보자 File &gt; new &gt; other 로 들어가 gradle을 검색한다. gradle project를 선택하고 다음으로넘어가면 위 화면이 나온다. next Project name 을 적어준다. next next 조금 기다리면 된다. Finish 버튼이 활성화 되면 클릭. build.gradle 파일에서 원하는 라이브러리를 명시하고 참고 ; gradle로 외부라이브러리 설치하기 build.gradle 을 우클릭하고 Gradle &gt; Refesh Gradle Project 를 누르면 외부 라이브러리들이 설치된다. 설치된 라이브러리들은 이클립스 익스플로러에서 Project and External Dependencies에서 확인할 수 있다. 참고 Windows에 Gradle 설치하기 by Jeongjin Kim 를 보고 따라했다. Gradle Beginner Tutorial 4 | How to create Gradle Project in Eclipse from Scratch | Windows &amp; Mac 을 보고 따라했다. gradle로 외부라이브러리 설치하기 gradle project 에서 runnable jar 생성하기","link":"/2020/10/05/gradle/"},{"title":"gradle로 외부라이브러리 설치하기","text":"원하는 라이브러리 명 + gadle 키워드로 구글링한다 나는 json-simple 을 받아보겠다. 카피 그래들 탭인지 잘 확인하고 카피한다. build.gradle 파일로와서 dependencies에 추가하고 저정한다. Gradle Project Refresh 끝!","link":"/2020/11/06/gradle%EB%A1%9C-%EC%99%B8%EB%B6%80%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0/"},{"title":"hexo db.json 초기화","text":"가끔 삭제한 페이지가 검색되거나 하는데, db.json을 삭제하면 알아서 갱신해준다.","link":"/2020/10/30/hexo-db-json-%EC%B4%88%EA%B8%B0%ED%99%94/"},{"title":"hexo 포스트 CRUD","text":"hexo에서 포스트 하는법! CRUD로 비유하여 알려줍니다 C 새 포스트 쓰기 hexo new &quot;새 포스트&quot; 위 명령으로 새 포스트를 만든다. source/_posts/새-포스트.md 경로에 새로운 md가 만들어 진다. 해당 md를 열어 마크다운을 활용해서 글을 쓴다. 마크 다운 사용법은 여기 참고한다. hexo 사용법은 여기 참고한다. R 포스트 읽기hexo server 위 명령으로 로컬에서 내가 쓴 포스트가 잘 나오는지 확인해본다. U 포스트 수정하기 source/_posts 경로에서 수정하고 싶은 포스트를 찾아 수정한다. 업데이트 시각은 자동 갱신되니까 걱정하지 말도록. D 포스트 삭제하기 source/_posts 경로에서 삭제하고 싶은 포스트를 찾아 삭제한다. 그냥 글을 숨기고 싶다면 source 디렉터리 바깥으로 뺀다. APPLY 위 과정을 통해서 포스트를 CRUD 해봤다. 이제 깃허브 페이지에 적용시키고 싶다면 아래 명령을 사용한다.hexo generate &amp; hexo deploy","link":"/2020/09/22/hexo-%ED%8F%AC%EC%8A%A4%ED%8A%B8-CRUD/"},{"title":"hexo new 할때 기본틀 지정하기","text":"새로 글을 쓸때마다 tags, category 지정하는게 귀찮아… 근데 자동으로 세팅해버리기 Front-matter 전문 용어로는 Front-matter 라고 한다. 설정하기 1234567---title: {{ title }}date: {{ date }}category: blogtags: - tag1thumbnail: /images/ scaffolds/post.md 를 입맛대로 수정한다. title, date 라는 변수를 사용할 수 있다.. 더 사용할 수 있는 변수는 여기를 참고한다. 같은 방법으로 page나 draft 도 수정할 수 있다. 재밌는 팁 {{ title.substring(1,title.length-1).replace(' ','-') }} 이런식으로 자바스크립트를 사용할 수 있다. 좋은 방법은 아닌 것 같은데.. 그냥 그럴 수 있다!","link":"/2020/09/17/hexo-new-%ED%95%A0%EB%95%8C-%EA%B8%B0%EB%B3%B8%ED%8B%80-%EC%A7%80%EC%A0%95%ED%95%98%EA%B8%B0/"},{"title":"hexo에서 초안, 작성중 사용하기","text":"너무 많은 포스트들 속에.. 파묻혀있는 새 글 draft 사용하기cmd1hexo new draft &quot;hexo에서 초안, 작성중 사용하기&quot; layout hexo에서는 새 포스트를 생서할때 layout이라는 것을 지정할 수 있다. 기본적으로 3개의 레이아웃이 있다. post, draft, page post레이아웃은 기본값이다. source/_posts/ 아래에 생성되게 만든다. page레이아웃은 페이지를 생성한다. source/ 아래에 생성되게 만든다. draft레이아웃은 source/_drafts/ 아래에 생성되게 만든다. Draft source/_drafts/ 아래에 생성된 md들은 기본적으로 렌더링 되지 않는다. 즉, 배포해도 블로그에 표시되지 않는다. 따라서 작성중인 글을 노출시키지 않을 수 있다. 또 포스트가 많아지면서 source/_posts 디렉터리가 복잡해지는데, 여기서 스크롤해가면서 작성중인 글을 힘들게 찾을 필요가 없다. 작성완료하는 법 포스팅이 끝나면 이제 _posts 디렉터리로 옮기면 된다. cmd123hexo publish [layout] [작성 완료한 포스트 파일명]hexo publish aws aws-공부 드래그 앤 드랍으로 직접 posts 폴더로 옮겨줄 수도 있는데 publish 명령을 사용하게 되면 layout을 지정할 수 있다. scaffolds 디렉터리에 만들어준 틀대로 front-matter가 바뀐다. layout은 생략하면 기본값으로 post가 적용된다. 로컬에서 테스트하기 아쉽게도 우리가 알고 있는 hexo server로는 draft가 노출되지 않는다. cmd1hexo server --draft 근데 --draft 옵션을 사용하면 source/_drafts 디렉터리에 있는 md파일도 렌더링되어 나타나게 된다.","link":"/2020/09/22/hexo%EC%97%90%EC%84%9C-%EC%B4%88%EC%95%88-%EC%9E%91%EC%84%B1%EC%A4%91-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"title":"inline style vs !important","text":"!important 승 갑자기 인라인에서 정의한 스타일과 !important 중에 누가 더 강력한지 궁금해 졌다. 123h1 { color: red !important;} index.html123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 style=&quot;color: blue&quot;&gt;hello world&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2020/11/09/inline-style-vs-important/"},{"title":"hosted with ❤ by GitHub로 코드 표시하는 법","text":"Github Gist 전문 용어로 Gist 라고 하며, 코드 블럭을 순수 md로도 표현할 수 있는데 Gist로도 할 수 있다. 여기저기 여러 화면에서 중복되어서 씌여지는 코드가 있다. 그런데 코드에 오타가 나서 수정을 한다고하자. md로 작성했으면 복사 붙여넣기로 인해 일일이 다 수정해야한다. 그런데 gist로 작성했으면 그냥 gist에 들어가서 수정하면 다 반영이 된다! Code Snippet 내용이 되는 코드들을 코드 스니펫이라고 부른다!","link":"/2020/09/17/hosted-with-%E2%9D%A4-by-GitHub%EB%A1%9C-%EC%BD%94%EB%93%9C-%ED%91%9C%EC%8B%9C%ED%95%98%EB%8A%94-%EB%B2%95/"},{"title":"hexo tag plugin 유튜브 재생목록 넣는법","text":"hexo post.md1{% youtube PL9hW1uS6HUfscJ9DHkOSoOX45MjXduUxo 'playlist' %} 게시하고싶은 재생목록의 id값을 알아온다. 재생목록을 가져온경우에는 id 뒤에 'playlist'를 붙여주면 된다. 나는 playlist라는 카테고리를 만들고 내가 듣는 노래를 이달의 재생목록처럼 업로드할려고 hexo에서 재생목록 표현하는 방법이 없나하고 알아보았다. 유튜브 재생목록 id 알아내기 https://www.youtube.com/playlist?list=PLdEiQV70x8ZGjg6ONGRZcZKIXMosQ6k-Bid : PLdEiQV70x8ZGjg6ONGRZcZKIXMosQ6k-B 게시하고싶은 재생목록에 들어가면 url에 list라는 파라매터가 있는데 그게 id이다. hexo tag-plugin12345{% youtube lJIrF4YjHfQ %}{% youtube PL9hW1uS6HUfscJ9DHkOSoOX45MjXduUxo 'playlist' %}{% youtube lJIrF4YjHfQ false %}{% youtube PL9hW1uS6HUfscJ9DHkOSoOX45MjXduUxo 'playlist' false %} 기본 md에서는 표현하지 못하는 것을 표현하게 해줌 당연히 hexo 블로그에서만 사용가능 맨 마지막에 false를 붙여주면 Enable privacy-enhanced mode 라고 유튜브 쿠키를 사용하지 않도록 한다. 참고 https://hexo.io/ko/docs/tag-plugins.html#Examples","link":"/2020/11/03/hexo-tag-plugin-%EC%9C%A0%ED%8A%9C%EB%B8%8C-%EC%9E%AC%EC%83%9D%EB%AA%A9%EB%A1%9D-%EB%84%A3%EB%8A%94%EB%B2%95/"},{"title":"java 카테고리 생성","text":"java 공부한 내용 올리기","link":"/2020/09/21/java-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC-%EC%83%9D%EC%84%B1/"},{"title":"javadoc 만들고 github에서 보기","text":"코드따로 문서따로… 하지 않고 한번에 해결하기 또 만든 javadoc을 깃허브에서 보여주는법! 따라하기준비물 이클립스 시작 나는 이 영상보고 따라했다. 코드는 아무렇게나, 자바독 주석도 아무렇게나 원하는 대로 만들면된다. 자바독 주석으로! App.java1234567891011121314151617181920212223242526272829303132333435363738package application;/** * Date: 2020-09-22 * This is a simple application for adding two integers. * @author chin_ * @version 1.0 */public class App { /** * int value for first number */ public int a; /** * int value for second number */ public int b; /** * This method adds x and y and returns the int result. * @param x first int value * @param y second int value * @return returning int value result from x + y */ public int sum(int x, int y) { return x + y; } /**The main method of this application * @param args array of string arguments. */ public static void main(String[] args) { }} /** */ 이런식으로 만든다. 설명하고 싶은 변수나 메소드 선언부에 커서를 두고 alt + shift + j 하면 자바독 주석이 생긴다. 열심히 설명 적고.. 자바독을 생성한다. 자신의 jdk 폴더로 가서 javadoc.exe를 지정해주고, (이미 세팅되어 있으면 패스) javadoc문서가 나올 경로를 지정한다. 기본값으로 (프로젝트명)\\doc 이렇게 되어있을 텐데, (프로젝트명)\\docs로 수정한다. docs가 깃허브 페이지를 통해 문서를 보여줄때 경로 규격이다. 또 docs폴더는 프로젝트 루트에 존재해야한다. Finish를 눌러 완료하면 javadoc 문서가 완성된다. cmd1git init 이제 git init 한다 .gitignore123456789101112131415161718192021222324252627282930# Created by https://www.toptal.com/developers/gitignore/api/java# Edit at https://www.toptal.com/developers/gitignore?templates=java### Java #### Compiled class file*.class# Log file*.log# BlueJ files*.ctxt# Mobile Tools for Java (J2ME).mtj.tmp/# Package Files #*.jar*.war*.nar*.ear*.zip*.tar.gz*.rar# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xmlhs_err_pid*# End of https://www.toptal.com/developers/gitignore/api/java 위 내용으로 .gitignore 파일을 추가한다. java 프로젝트용 .gitignore파일이다. 쉽게 .gitignore파일 만드는 곳 이제 깃허브 저장소로 올린다. 브라우저로 방금 만든 저장소 세팅에 들어간다. 브랜치를 마스터로 선택, /docs 선택 save 버튼 클릭 이렇게 설정하면 잠시후 깃허브에서 javadoc으로 만든 내 프로젝트 문서를 볼 수 있게된다. 너무 빨리 접속하면 GitHub Pages is temporarily down for maintenance. 메시지를 볼 수 있다. 여기까지 프로젝트 파일","link":"/2020/09/22/javadoc-%EB%A7%8C%EB%93%A4%EA%B3%A0-github%EC%97%90%EC%84%9C-%EB%B3%B4%EA%B8%B0/"},{"title":"linux node app 백그라운드 실행","text":"1nohup npm start &amp; ec2에서 24시간 돌아가는 웹 앱을 돌릴일이 생겼다. 그런데 처음에 그냥 마지막에 &amp;만 붙여주면 되겠지 하고 npm start &amp; 명령을 치고 리모트를 종료했더니, 리모트를 종료하는 순간 앱 실행도 멈췄다. 왜 그런가 했더니 단순히 &amp;을 붙이고 실행한 프로세스는 터미널이 종료하면 같이 꺼진다고 한다. nohup 리눅스에서는 특별한 패키지 설치없이도 완전한? 백그라운드 실행을 가능하게해주는 명령이 있다. 12nohup npm start &amp;exit 이렇게 실행하고 exit을 눌러 나와주면 터미널이 자동으로 닫힌다. 하지만 앱은 계속해서 실행되고 있다. exit 은 nohup이랑 관계없고, 그냥 터미널을 종료하는 명령이다 nohup 명령 후 아무키나 누르면 다시 터미널을 사용할 수 있는 상태가 된다. 참고 https://jahong.tistory.com/entry/EC2-deploy-server-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%A5%BC-%EB%B0%B1%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C%EC%97%90%EC%84%9C-%EC%8B%A4%ED%96%89%EC%8B%9C%ED%82%A4%EA%B8%B0","link":"/2020/10/30/linux-node-app-%EB%B0%B1%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C-%EC%8B%A4%ED%96%89/"},{"title":"mysql vs mysql2","text":"mysql2를 사용해보자 mysql2 노드 패키지 기존 mysql 패키지 보다 빠름 기존 mysql를 대체하는 것이 목표라고함 참고 sidorares/node-mysql2 Comparing mysql vs. mysql2 What is the difference between MySQL &amp; MySQL2 considering NodeJS","link":"/2020/11/10/mysql/"},{"title":"hexo server로 로컬에서 미리보기","text":"배포하기 전에 로컬에서 미리보자 hexo server 위 명령어를 통해서 로컬에서 내 블로그를 미리 볼 수 있다. 4000번 포트로 접속하면 된다. hexo server -p 3000 과 같이 -p 옵션을 통해서 포트를 지정할 수도 있다. 가장 좋은 점은 변경 사항이 있으면 바로바로 갱신되어 나온다. 실험적인 시도들을 먼저 로컬에서 해보고 잘되면, 배포할 수 있다. 팁 이미지를 수정했는데 적용이 안되어 보일 수 있는데 브라우저 캐시 문제다. 배포해서 깃허브에 올라가면 제대로 수정된 이미지가 보인다 깃허브에 배포해도 그 즉시 적용이 되지 않고 조금 시간이 걸린다. 따라서 hexo server이 좋다!","link":"/2020/09/17/hexo-server%EB%A1%9C-%EB%A1%9C%EC%BB%AC%EC%97%90%EC%84%9C-%EB%AF%B8%EB%A6%AC%EB%B3%B4%EA%B8%B0/"},{"title":"li point remove","text":"default.css123li { list-style-type: none;} li의 앞에 붙는 . 을 없앨 수 있다.","link":"/2020/11/03/li-point-remove/"},{"title":"no follow","text":"nofollow https://ko.wikipedia.org/wiki/Nofollow SEO 설정을 하면서 알게된 것이다. hexo-autonofollow 모듈을 설치해 외부 링크에 nofollow 속성을 넣어준다. 참고 ; 구글 서치 콘솔 가이드","link":"/2020/09/22/no-follow/"},{"title":"nodejs 파일 목록 출력하기","text":"printFileList.js123456const fs = require('fs');const dirPath = '.';fs.readdir(dirPath, (error, filelist) =&gt; { console.log(filelist);}); 은근히 자주 쓴다. dirPath 변수에 원하는 디렉터리의 경로를 적어주어 확인할 수 있다. 내가 활용한 곳 .dockerignore 파일을 추가했는데 동작할까? 궁금해서 람다 실행환경 디렉터리 구조 파악","link":"/2020/10/16/js%ED%8C%8C%EC%9D%BC%EB%AA%A9%EB%A1%9D/"},{"title":"nodejs 카테고리 생성","text":"nodejs 공부한 내용 올리기","link":"/2020/09/21/nodejs-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC-%EC%83%9D%EC%84%B1/"},{"title":"nodemon 변화감지 디렉터리 지정","text":"cmd1nodemon --watch app app/server.js nodemon을 사용해서 코드수정마다 서버를 자동으로 재시작하는데, view와 관련한 코드를 수정할 때 서버가 재시작되는 것은 불필요하고, 세션이 날라가는 등 오히려 불편할 수 있다. nodemon이 모든 프로젝트 디렉터리가 아닌 특정 디렉터리의 변화를 감시하고 재시작되는 것을 알아보자 명령어terminal1nodemon ./bin/www 보통 이렇게 아무것도 없이 사용하면, 거의 모든 변화마다 서버가 재시작된다. terminal1nodemon --watch routes ./bin/www --watch routes watch옵션을 넣어줌으로써 해당 디렉터리에서 변화가 있으면 재시작하도록 할 수 있다. terminal1nodemon --watch routes --watch libs ./bin/www 이런식으로 나열할 수 있다. 기본적으로 디렉터리명을 적어야하며, 하위디렉터리는 자동으로 포함된다. 그런데 여러개의 디렉터리를 나열을 해야하면은 반대로 무시할 디렉터리를 설정하는게 빠를 수 있다. config file로 설정nodemon.json12345678910111213141516{ &quot;restartable&quot;: &quot;rs&quot;, &quot;ignore&quot;: [&quot;.git&quot;, &quot;node_modules/**/node_modules&quot;], &quot;verbose&quot;: true, &quot;execMap&quot;: { &quot;js&quot;: &quot;node --harmony&quot; }, &quot;events&quot;: { &quot;restart&quot;: &quot;osascript -e 'display notification \\&quot;App restarted due to:\\n'$FILENAME'\\&quot; with title \\&quot;nodemon\\&quot;'&quot; }, &quot;watch&quot;: [&quot;test/fixtures/&quot;, &quot;test/samples/&quot;], &quot;env&quot;: { &quot;NODE_ENV&quot;: &quot;development&quot; }, &quot;ext&quot;: &quot;js,json&quot;} nodemon.json이름으로 파일을 하나 만들고 커스텀할 수 있다. 무시할 디렉터리를 ignore 배열에 나열하면 된다. 참고 https://github.com/remy/nodemon#monitoring-multiple-directories https://github.com/remy/nodemon/blob/master/doc/sample-nodemon.md","link":"/2020/11/02/nodemon-%EB%B3%80%ED%99%94%EA%B0%90%EC%A7%80-%EB%94%94%EB%A0%89%ED%84%B0%EB%A6%AC-%EC%A7%80%EC%A0%95/"},{"title":"playlist 202011","text":"~","link":"/2020/11/03/playlist-202011/"},{"title":"rds sqldump 하기","text":"cmd12345678mysqldump -h database-1.aaaaaaaaaaaa.ap-northeast-2.rds.amazonaws.com ^ -u root ^ -p12341234 ^ --port=3306 ^ --single-transaction ^ --routines ^ --triggers ^ --databases TestDB &gt; aaaa.sql 윈도우 cmd에서 aws rds mysqldump를 해보았다. 윈도우 따라하기 cmd를 관리자 권한으로 실행한다 cmd1cd C:\\Program Files\\MariaDB 10.5\\bin mysqldump.exe가 있는 경로까지 이동한다. (나는 로컬에 마리아 디비가 설치되어 있어서..) cmd1234567891011121314151617mysqldump -h {rds 엔드포인트} ^ -u root ^ -p{rds 비밀번호} ^ --port=3306 ^ --single-transaction ^ --routines ^ --triggers ^ --databases {db명} &gt; {백업파일위치}mysqldump -h database-1.aaaaaaaaaaaa.ap-northeast-2.rds.amazonaws.com ^ -u root ^ -p12341234 ^ --port=3306 ^ --single-transaction ^ --routines ^ --triggers ^ --databases TestDB &gt; aaaa.sql 자신에 맞게 설정하고 명령을 붙여넣는다","link":"/2020/10/21/rds-sqldump-%ED%95%98%EA%B8%B0/"},{"title":"RDS 삭제시 주의사항","text":"ㅠㅠ RDS 삭제 시 자동으로 스냅샷 생성 RDS를 삭제하면 자동으로 스냅샷? 백업같은 것을 생성한다. RDS를 사용중도아니고, 삭제하니까 비용이 생긴게 삭제하면서 생긴 스냅샷 보관 비용이였다. RDS를 삭제한다면 RDS 삭제 후 꼭 RDS &gt; 스냅샷 에서 생성된 스냅샷도 같이 삭제..","link":"/2020/11/06/rds-%EC%82%AD%EC%A0%9C%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD/"},{"title":"playlist 201906","text":"~","link":"/2020/11/03/playlist-201906/"},{"title":"nodejs + socketio 로 만드는 채팅 앱, 카카오톡 클론코딩?","text":"Web Dev Simplified의 Build a Real Time Chat App With Node.js And Socket.io을 보고 따라만들기 nodejs에서 html과 socket.io로 간단하게 챗앱을 만드는 것을 따라해보았다. Web Dev Simplified 정말 심플하게 잘알려준다.. ㄷㄷ 따라 만들면서 행복했다. 따라만들고 카카오톡같은 css를 입히고, 디테일한 기능을 추가 해줬다. 추가한 기능 고유한 프로필 사진 생성(랜덤색 + 이니셜) 현재 채팅에 참가한 유저 목록 위젯 width값이 작아지면 유저 목록 위젯 숨김 width값이 작아지면 프로필 사진 영역 숨김 같은 사람이 연달아 올릴 때 프로필 사진 생략 같은 사람이 같은 시간에 연달아 올릴 때 가장 최근 메시지에만 시간표시 메시지는 plain text로 표시 소스코드 chat-app-nodejs-and-socketio","link":"/2020/11/03/nodejs-socketio-%EB%A1%9C-%EB%A7%8C%EB%93%9C%EB%8A%94-%EC%B1%84%ED%8C%85-%EC%95%B1/"},{"title":"npm 명령어","text":"내가 쓰는 명령어1234567npm inpm i [패키지명]npm i [패키지명] -Dnpm i [패키지명] -gnpm startnpm run [script] 이렇게를 주로 쓴다. 짧게 쓰는 npm 명령어 npm i == npm install npm i -D == npm i --save-dev npm i -g == npm i --global npm install option -D ; 개발할때만 쓰이는 패키지를 설치할때 사용한다. 배포할때 포함되지 않는다. -g ; 패키지 전역 설치. hexo같은 cli에 바로 명령어를 치는 놈들을 보통 이렇게 설치한다. 참고 npm i [패키지명] -S 이렇게 --save옵션을 줘야만 package.json에 들어갔는데, npm5부터 기본값이라 안적어도 된다. npm scriptspackage.json1234567&quot;scripts&quot;: { &quot;build&quot;: &quot;hexo generate&quot;, &quot;clean&quot;: &quot;hexo clean&quot;, &quot;deploy&quot;: &quot;hexo deploy&quot;, &quot;test&quot;: &quot;hexo server&quot;, &quot;start&quot;: &quot;hexo generate &amp; hexo deploy &amp; git add . &amp; git commit -m &quot;}, 여기에 명령을 등록시켜놓고 npm run build 이런식으로 사용한다. 여기서 test, start 스크립트는 run을 생략하여 npm start, npm test 이런식으로 사용할 수 있다. 그 외에 stop, restart 를 run 없이 바로 사용할 수 있다.","link":"/2020/09/21/npm-%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"title":"react 카테고리 생성","text":"react 공부한 내용 올리기","link":"/2020/09/18/react-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC-%EC%83%9D%EC%84%B1/"},{"title":"readme.md] ios-swift-ImageFinder","text":"gist로 다른 프로젝트의 readme 가져오기… 실험중","link":"/2020/09/17/readme-md-ios-swift-ImageFinder/"},{"title":"sam 시작하기","text":"sam을 이용해서 hello world 프로젝트 만들어 보기 nodejs로 만든다 전제조건 aws 계정 (프리티어) aws cli 설치 sam cli 설치 (aws cli, sam cli 순으로 설치한다.) Credentilas Setting (aws configure) SAM(Serverless Application Model) 겁나 어려워 보이는데 그냥 람다 생성기라고 생각하면 된다. 로컬에서 편하게 vscode로 람다함수짜고 yml 파일 수정해서..! 로컬 테스트 환경도 제공한다! 따라하기cmd1234567sam initC:\\tmp&gt;sam initWhich template source would you like to use? 1 - AWS Quick Start Templates 2 - Custom Template LocationChoice: 1번, 1번해서 AWS Quick Start Templates, nodejs 를 골라준다. cmd1Project name [sam-app]: hello-world 프로젝트명 설정하면, 샘플 프로젝트를 가져온다. cmd12345678910AWS quick start application templates: 1 - Hello World Example 2 - Step Functions Sample App (Stock Trader) 3 - Quick Start: From Scratch 4 - Quick Start: Scheduled Events 5 - Quick Start: S3 6 - Quick Start: SNS 7 - Quick Start: SQS 8 - Quick Start: Web BackendTemplate selection: 1 1번 선택하여 헬로월드 템플릿을 받아온다. cmd1cd hello-world 이제 생성된 프로젝트로 들어간다. 1234567891011.├── events│ └── event.json├── hello-world│ ├── tests/│ ├── .npmignore│ ├── app.js│ └── package.json├── .gitignore├── README.md└── template.yaml 디렉터리 구조는 이러하다. 여기서 중요한 파일은 hello-world/app.js와 template.yaml이다. 2개 파일 소스 대충 어떻게 생겼는지 봐보고 빌드해본다. cmd12345678910111213141516171819sam buildC:\\tmp\\hello-world&gt;sam buildBuilding function 'HelloWorldFunction'Running NodejsNpmBuilder:NpmPackRunning NodejsNpmBuilder:CopyNpmrcRunning NodejsNpmBuilder:CopySourceRunning NodejsNpmBuilder:NpmInstallRunning NodejsNpmBuilder:CleanUpNpmrcBuild SucceededBuilt Artifacts : .aws-sam\\buildBuilt Template : .aws-sam\\build\\template.yamlCommands you can use next=========================[*] Invoke Function: sam local invoke[*] Deploy: sam deploy --guided .aws-sam 이라는 폴더가 생성된다. 1234567.aws-sam└── build ├── HelloWorldFunction │ ├── node_modules/ │ ├── app.js │ └── package.json └── template.yaml 이제 배포해보자 cmd1sam deploy -g 배포하자. -g옵션은 --guided 와 동일하다. 이 옵션은 최초에 배포할때만 사용된다. cmd log123456789101112131415Configuring SAM deploy====================== Looking for samconfig.toml : Not found Setting default arguments for 'sam deploy' ========================================= Stack Name [sam-app]: test-sam-app AWS Region [us-east-1]: ap-northeast-2 #Shows you resources changes to be deployed and require a 'Y' to initiate deploy Confirm changes before deploy [y/N]: y #SAM needs permission to be able to create roles to connect to the resources in your template Allow SAM CLI IAM role creation [Y/n]: y HelloWorldFunction may not have authorization defined, Is this okay? [y/N]: y Save arguments to samconfig.toml [Y/n]: y 먼저 Stack Name을 지정해준다. 공란으로 하면 sam-app으로 적용된다. 다음은 리전 설정이다. 나는 서울 ap-northeast-2로 지정했다 다음은 전부다 y 해준다. cmd log123456789101112131415161718CloudFormation stack changeset----------------Operation LogicalResourceId ResourceType----------------+ Add HelloWorldFunctionHelloWorldPermissionProd AWS::Lambda::Permission+ Add HelloWorldFunctionRole AWS::IAM::Role+ Add HelloWorldFunction AWS::Lambda::Function+ Add ServerlessRestApiDeployment47fc2d5f9d AWS::ApiGateway::Deployment+ Add ServerlessRestApiProdStage AWS::ApiGateway::Stage+ Add ServerlessRestApi AWS::ApiGateway::RestApi----------------Changeset created successfully. arn:aws:cloudformation:ap-northeast-2:111111111111:changeSet/samcli-deploy1600652952/89cf8cb3-a626-44ef-bd26-815dacedaa8ePreviewing CloudFormation changeset before deployment======================================================Deploy this changeset? [y/N]: y 또 어쩌구 저쩌구 나오면서 마지막 확인을 받는데 y 해준다. cmd log1Successfully created/updated stack - test-sam-app in ap-northeast-2 그러면 시간이 쫌 걸리면서 aws에 올라가게 된다. 또 samconfig.toml 파일이 생성된 것을 확인할 수 있다. 이제 브라우저를 열어서 aws lambda 로 들어간다 위와 같이 [스택네임]-HelloWorldFunction이름의 함수 하나가 생성되었다. 눌러서 들어간다 이런 화면이 나온다 api 게이트웨이를 클릭한다. 그러면 아래 화면이 api 게이트웨이로 바뀐다. 거기서 다시 세부 정보를 클릭해서 api 엔드포인트를 확인한다. 엔드포인트를 눌러 접속한다. {&quot;message&quot;:&quot;hello world&quot;}이 보이면 성공이다. 이렇게 다짜고짜 sam으로 람다를 만들어 보았다. 해설 sam Hello World Example template를 이용해서 람다를 만들었다. 이 람다는 어떤 주소로 접속하면 hello world를 반환하는 람다이다. 현재 프로젝트 구조를 잘 살펴보면 sam을 익히면 된다. 먼저 이 {&quot;message&quot;:&quot;hello world&quot;}는 어디서 왔을까? hello-world/app.js1234567891011121314151617exports.lambdaHandler = async (event, context) =&gt; { try { // const ret = await axios(url); response = { statusCode: 200, body: JSON.stringify({ message: 'hello world', // location: ret.data.trim() }), }; } catch (err) { console.log(err); return err; } return response;}; lambdaHandler라는 함수가 있는데 response객체를 반환한다. 근데 우리는 {“message”:”hello world”} 만 보이니까 body에 있는 내용을 조작하면 우리가 원하는 내용을 보낼 수 있겠구나 생각할 수 있다. 그러면 이 함수를 실행시키는 트리거, s22xid3g26.execute-api.ap-northeast-2.amazonaws.com/Prod/hello api 게이트웨이의 엔드포인트는 어디서 설정되었을까? template.yaml12345678910111213Resources: HelloWorldFunction: Type: AWS::Serverless::Function # More info about Function Resource: https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md#awsserverlessfunction Properties: CodeUri: hello-world/ Handler: app.lambdaHandler Runtime: nodejs12.x Events: HelloWorld: Type: Api # More info about API Event Source: https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md#api Properties: Path: /hello Method: get template.yaml을 보면 Events 아래 Type: Api가 보인다. hello라는 Path로 get 요청이 왔을때 라고 이해할 수 있다. 이제 이를 토대로 람다를 업그레이드 해보자","link":"/2020/09/21/sam-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"sample-img","text":"web 개발하면서 샘플 이미지를 넣어보고 싶을 때.. Placeholder.com https://placeholder.com/#How_To_Use_Our_Placeholders &lt;- 사용법 index.html12&lt;img src=&quot;https://via.placeholder.com/468x200?text=Sample+Image&quot; /&gt;&lt;img src=&quot;https://via.placeholder.com/{가로}x{세로}?text={문자열}&quot; /&gt;","link":"/2020/10/05/sample-img/"},{"title":"samconfig.toml 에서 sam deploy 자동 y 설정하기","text":"cmd log123Previewing CloudFormation changeset before deployment======================================================Deploy this changeset? [y/N]: y deploy를 자주하다보면 이 y 누르는게 힘들다…. samconfig.toml 설정하기samconfig.toml12345678910version = 0.1[default][default.deploy][default.deploy.parameters]stack_name = &quot;test-sam-app&quot;s3_bucket = &quot;aws-sam-cli-managed-default-samclisourcebucket-mqu19xn1bzoq&quot;s3_prefix = &quot;test-sam-app&quot;region = &quot;ap-northeast-2&quot;confirm_changeset = falsecapabilities = &quot;CAPABILITY_IAM&quot; 처음 배포할때 -g옵션에서 설정했던것이 samconfig.toml에 저장되어있다. 1confirm_changeset = false 여기서 confirm_changeset을 flase로 바꿔주면 중간에 확인 과정을 생략할 수 있다. 편안..!","link":"/2020/09/21/samconfig-toml-%EC%97%90%EC%84%9C-sam-deploy-%EC%9E%90%EB%8F%99-y-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/"},{"title":"sam에서 노드 모듈을 레이어로 빼기","text":"람다는 가벼운게 최고다. 노드 모듈은 따로 빼버리기! Lambda Layer nodejs로 치면 node_modules이다. 람다 함수에서 노드 모듈같은 종속성을 람다 함수 밖에으로 뺄 수 있음 왜 쓰냐? 공통적으로 쓰이는 패키지들을 묶어서 관리할 수 있음. 람다함수가 커지면 브라우저로 aws console에서 코드 조회를 못함. 따라하기외부 모듈을 사용해보기 sam template.yaml에서 layer설정할 수 있다. 지난번에 만든 hello world에서 이어서 진행해 보겠다. hello-world/app.js123// const axios = require('axios')// const url = 'http://checkip.amazonaws.com/';let response; hello-world/app.js123const axios = require('axios');const url = 'http://checkip.amazonaws.com/';let response; 맨 윗 2줄 주석 해제한다. hello-world/app.js1234567891011121314151617exports.lambdaHandler = async (event, context) =&gt; { try { // const ret = await axios(url); response = { statusCode: 200, body: JSON.stringify({ message: 'hello world', // location: ret.data.trim(), }), }; } catch (err) { console.log(err); return err; } return response;}; hello-world/app.js1234567891011121314151617exports.lambdaHandler = async (event, context) =&gt; { try { const ret = await axios(url); response = { statusCode: 200, body: JSON.stringify({ message: 'hello world', location: ret.data.trim(), }), }; } catch (err) { console.log(err); return err; } return response;}; 여기도 2곳 주석을 해제한다. package.json12345678910111213141516171819{ &quot;name&quot;: &quot;hello_world&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;hello world sample for NodeJS&quot;, &quot;main&quot;: &quot;app.js&quot;, &quot;repository&quot;: &quot;https://github.com/awslabs/aws-sam-cli/tree/develop/samcli/local/init/templates/cookiecutter-aws-sam-hello-nodejs&quot;, &quot;author&quot;: &quot;SAM CLI&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;dependencies&quot;: { &quot;axios&quot;: &quot;^0.18.0&quot; }, &quot;scripts&quot;: { &quot;test&quot;: &quot;mocha tests/unit/&quot; }, &quot;devDependencies&quot;: { &quot;chai&quot;: &quot;^4.2.0&quot;, &quot;mocha&quot;: &quot;^6.1.4&quot; }} 필요없는 devDependencies 를 없앤다. test 할때 필요한 패키지인데, 우리는 안쓸거다. package.json123456789101112131415{ &quot;name&quot;: &quot;hello_world&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;hello world sample for NodeJS&quot;, &quot;main&quot;: &quot;app.js&quot;, &quot;repository&quot;: &quot;https://github.com/awslabs/aws-sam-cli/tree/develop/samcli/local/init/templates/cookiecutter-aws-sam-hello-nodejs&quot;, &quot;author&quot;: &quot;SAM CLI&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;dependencies&quot;: { &quot;axios&quot;: &quot;^0.18.0&quot; }, &quot;scripts&quot;: { &quot;test&quot;: &quot;mocha tests/unit/&quot; }} 없애면 이런 모양이 된다. cmd12cd hello-worldnpm i app.js가 있는 hello-world 디렉토리로 와서 종속성을 설치한다. 12345678910111213.├── .aws-sam/├── events│ └── event.json├── hello-world│ ├── node_modules/│ ├── tests/│ ├── .npmignore│ ├── app.js│ └── package.json├── .gitignore├── README.md└── template.yaml node_modules 폴더가 생기면서 현재 디렉터리 구조는 이렇게 된다. hello-world/tests 폴더를 삭제한다. 우리는 안쓴다. events 폴더를 삭제한다. 우리는 안쓴다. .aws-sam 폴더를 삭제한다. 이 폴더가 있으면 local start-api 했을때 .aws-sam를 우선 참조하기때문에 소스 코드에 변경사항이 발생해도 반영되지 않는다. 123456789.├── hello-world│ ├── node_modules/│ ├── .npmignore│ ├── app.js│ └── package.json├── .gitignore├── README.md└── template.yaml 현재까지 디렉터리 구조는 이렇게 된다. 이제 로컬에서 테스트 해보자 참고 ; 로컬에서 sam 테스트하기 cmd12cd ..sam local start-api --skip-pull-image cmd log1234567C:\\tmp\\hello-world\\hello-world&gt;cd ..C:\\tmp\\hello-world&gt;sam local start-api --skip-pull-imageMounting HelloWorldFunction at http://127.0.0.1:3000/hello [GET]You can now browse to the above endpoints to invoke your functions. You do not need to restart/reload SAM CLI while working on your functions, changes will be reflected instantly/automatically. You only need to restart SAMCLI if you update your AWS SAM template2020-09-21 14:49:47 * Running on http://127.0.0.1:3000/ (Press CTRL+C to quit) http://127.0.0.1:3000/hello 에 접속한다. 이렇게 location에 자신의 공인 IP가 뜨면 성공이다. 주석 해제한 소스 코드는 axios라는 모듈로 http://checkip.amazonaws.com/ 에서 공인 ip를 얻어와 response 객체에 location이라는 이름으로 담아서 반환한 것이다. http://checkip.amazonaws.com/ 에 접속해 보면 알 수 있듯이 자신의 공인 ip를 알려주는 api다. 여기까지 axios라는 모듈을 이용해봤다. 이제 sam build &amp; sam deploy 를 통해 aws에 올려보자 cmd1sam build &amp; sam deploy 배포가 완료되면 엔드 포인트를 통해서 aws에 올린 람다를 실행해보자. 그러면 이상한 아이피가 나온다. 이게 aws 컴퓨터중에서 현재 람다가 실행된 컴퓨터의 공인 ip 주소이다. 여기까지 잘 작동되는 것이 확인 되었다. 외부 모듈을 layer로 빼기 이제 브라우저를 열고 aws console &gt; lambda &gt; HelloWorldFunction 으로 가서 함수가 어떻게 생겻는지 확인한다. 함수 안에 노드 모듈이 포함되어 있는 것을 확인할 수 있다. 이제 이 글의 핵심인 node_modules 폴더를 layer로 빼볼것이다. 레이어를 만드는 방법이 여러가지가 있지만 나는 내 방식을 설명해 보겠다. 나는 cmd명령을 사용할 것이다. template.yaml에서 빨간 네모 부분을 추가한다. template.yaml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950AWSTemplateFormatVersion: '2010-09-09'Transform: AWS::Serverless-2016-10-31Description: &gt; hello-world Sample SAM Template for hello-world# More info about Globals: https://github.com/awslabs/serverless-application-model/blob/master/docs/globals.rstGlobals: Function: Timeout: 3Resources: HelloWorldFunction: Type: AWS::Serverless::Function # More info about Function Resource: https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md#awsserverlessfunction Properties: Layers: - !Ref DependencyLayer CodeUri: hello-world/ Handler: app.lambdaHandler Runtime: nodejs12.x Events: HelloWorld: Type: Api # More info about API Event Source: https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md#api Properties: Path: /hello Method: get DependencyLayer: Type: AWS::Serverless::LayerVersion Properties: LayerName: HelloWorldFunction-layer Description: Dependencies for HelloWorldFunction ContentUri: opt/ CompatibleRuntimes: - nodejs12.x RetentionPolicy: RetainOutputs: # ServerlessRestApi is an implicit API created out of Events key under Serverless::Function # Find out more about other implicit resources you can reference within SAM # https://github.com/awslabs/serverless-application-model/blob/master/docs/internals/generated_resources.rst#api HelloWorldApi: Description: 'API Gateway endpoint URL for Prod stage for Hello World function' Value: !Sub 'https://${ServerlessRestApi}.execute-api.${AWS::Region}.amazonaws.com/Prod/hello/' HelloWorldFunction: Description: 'Hello World Lambda Function ARN' Value: !GetAtt HelloWorldFunction.Arn HelloWorldFunctionIamRole: Description: 'Implicit IAM Role created for Hello World function' Value: !GetAtt HelloWorldFunctionRole.Arn 최종코드는 이러하다. 눈여겨 봐야할 것은 Resources아래에 DependencyLayer라는 이름으로 layer정의하고 ContentUri: opt/ 를 지정한다. 이 opt 디렉터리에 우리가 layer로 따로뺄 패키지가 들어가게 될것이다. 이제 배치파일을 2개 만들거다. layer.bat1234567echo layer processset functionDir=HelloWorldFunctionecho y|rmdir /s opt\\nodejsmkdir opt\\nodejsmove .aws-sam\\build\\%functionDir%\\node_modules opt\\nodejs layer.bat을 sam project 최상위에 만들고 내용은 위와같이 한다. set functionDir=HelloWorldFunction 에서는 template.yaml에서 지정한 함수명을 적어주면 된다. template.yaml을 안거드렸으면 HelloWorldFunction이니까 그대로 사용하면 된다. template.yaml123Resources: HelloWorldFunction: // &lt;- 이 이름과 매칭되도록 Type: AWS::Serverless::Function deploy.bat123echo deploysam build &amp; layer.bat &amp; sam deploy 또 deploy.bat을 sam project 최상위에 만들고 내용은 위와같이 한다. build하고 방금 만든 layer.bat으로 배포될 빌드 디렉터리에서 node_modules을 opt 디렉터리로 옮기고 deploy한다. 결과는 이렇게 된다. 1.2. 디렉터리 구조를 봐보면 node_modules 폴더가 없다 3.4. yaml에서 지정한 layer 등록되어 있는 것을 확인할 수 있다. 당연하게도 이 함수는 잘 동작한다. 여기까지 batch파일을 활용해서 노드모듈을 레이어로 빼는 방법을 알아보았다. 여기까지 프로젝트 파일","link":"/2020/09/21/sam%EC%97%90%EC%84%9C-%EB%85%B8%EB%93%9C-%EB%AA%A8%EB%93%88%EC%9D%84-%EB%A0%88%EC%9D%B4%EC%96%B4%EB%A1%9C-%EB%B9%BC%EA%B8%B0/"},{"title":"reqres.in으로 ajax 연습하기","text":"Reqres 에서 다양한 api를 제공하고있다. cors를 허용하기 때문에 localhost에서도 요청을보내고 응답을 받을 수 있다. ajax 연습이나, 간단한 앱을 만들 때, 서버를 만들지 않고, reqres에서 제공하는 api를 사용할 수 있겠다. get api https://reqres.in/api/users?page=2 // 유저 목록 2페이지 보기https://reqres.in/api/users/2 // 2번 유저 보기https://reqres.in/api/users/23 // 23번 유저 보기(없는 유저) // products보기, products 부분은 어떤 문자열로든 치환이 가능해서 원하는 느낌의 문자열을 적어주면된다.https://reqres.in/api/productshttps://reqres.in/api/products/1","link":"/2020/11/03/reqres-in%EC%9C%BC%EB%A1%9C-ajax-%EC%97%B0%EC%8A%B5%ED%95%98%EA%B8%B0/"},{"title":"sam template.yaml 익히는 빠른 방법","text":"브라우저에서 aws console 통해 람다 수정해보고 작업 &gt; 내보내기 &gt; aws sam 파일 다운로드 하기 여기서 aws sam 파일은 template.yaml이다. 익히는 법 처음에 할때는 gui만큼 쉬운게 없다. sam을 시작하면 yaml을 어떻게 건드려야할지 감이 안올 것이다. 그럴때는 역으로 브라우저에서 내가 설정할 권한들을 설정하고 저장한다. 그리고 작업 &gt; 내보내기 &gt; aws sam 파일 다운로드를 통해 어떻게 yaml이 수정되었는지 확인해보면 된다.","link":"/2020/09/21/sam-template-yaml-%EC%9D%B5%ED%9E%88%EB%8A%94-%EB%B9%A0%EB%A5%B8-%EB%B0%A9%EB%B2%95/"},{"title":"sqldump","text":"내 mysql, mariadb 백업, 덤프하는 방법 mysqldumpcmd123mysqldump -u root -p --databases {db_name} &gt; {백업파일위치}mysqldump -u root -p --databases mydb &gt; backup.sql 현재 db내용을 백업할 수 있다. ‘mysqldump’은(는) 내부 또는 외부 명령, 실행할 수 있는 프로그램, 또는 배치 파일이 아닙니다. mysql 또는 mariadb의 경우… db 설치 경로에 들어가서 mysqldump를 검색한다. 내 경우 C:\\Program Files\\MariaDB 10.5\\bin이 경로에 있었다. 해당 위치에서 cmd를 실행시키고 명령을 실행해주면된다. 액세스가 거부되었습니다. cmd를 관리자 권한으로 실행한다. mysql123mysql &lt; {백업파일위치}mysql &lt; backup.sql 이렇게 백업해둔 .sql파일로 복구할 수 있다.","link":"/2020/10/21/sqldump/"},{"title":"shell script 경로에서 실행","text":"bash123dirpath=`dirname $0`echo $dirpathcd $dirpath 셸 스크립트 파일 경로로부터 명령을 실행할 수 있다","link":"/2020/11/02/shell-script-%EA%B2%BD%EB%A1%9C%EC%97%90%EC%84%9C-%EC%8B%A4%ED%96%89/"},{"title":"swift 카테고리 생성","text":"swift … 아이폰앱 만들면서 느낀점을 쓸 예정..","link":"/2020/09/17/swift%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC-%EC%83%9D%EC%84%B1/"},{"title":"toc (목차) 사용하기","text":"안녕하세요저는친성입니다만나서반가워요다시만나요123456789---title: toc 사용하기date: 2020-09-17 09:22:30category: blogtags: - hexotoc: true--- toc: true를 추가시켜주면 헤딩 태그(h1~h6)를 파싱하여 목차를 만들어 줍니다. 처음에 적용해 보시면 목차 깊이가 2개밖에 되지 않는다고 생각할 수 있는데 스크롤 해보시면 숨겨져있다가 나옵니다!","link":"/2020/09/17/toc-%EB%AA%A9%EC%B0%A8-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"title":"ts-node","text":"terminal1ts-node src/index.ts tsc를 통해 .js파일로 만들고, js파일을 실행하는 것이 아니라 바로 .ts 파일을 실행하는 것처럼 보여준다. 따로 .js파일은 생성되지 않는다. ts-node 설치terminal1npm install -g ts-node 참고 TypeStrong/ts-node","link":"/2020/11/10/ts-node/"},{"title":"unity 카테고리 생성","text":"지금은 안하지만.. 기록차.. 예전에 헀던 내용 올리기","link":"/2020/09/18/unity-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC-%EC%83%9D%EC%84%B1/"},{"title":"vim 어드벤쳐","text":"vim 익히는데 게임이 있다. https://vim-adventures.com/ 얄팍한 코딩사전님의 영상보고 혹해서 해봤는데 나는 역시 마우스가…","link":"/2020/09/17/vim-%EC%96%B4%EB%93%9C%EB%B2%A4%EC%B3%90/"},{"title":"vscode search exclude setting","text":"검색결과에서 제외할 디렉터리, 파일 설정하기 세팅창 화면으로 Ctrl + Shift + P 를 누르고 setting을 입력한다 Preferences: Open Settings (UI)로 들어간다 search: exclude 설정 검색에서 제외할 패턴들을 입력한다. 검색 제외 적용하기 … 을 클릭해서 디테일 표시 file to exclude 영역에 아이콘 활성화 왼쪽이 비활성화일 때 오른쪽이 활성화일 때 쓸때없는 것을 제외함으로써 쾌적한 검색결과를 확인할 수 있다. 상위 옵션 ; files.exclude vscode 탐색기에서 존재자체를 없애버리는 얘다. 여기서 제외된 디렉터리는 당연히 검색에서도 제외됨으로 search.exclude의 상위 호환이라고 볼 수 있다.","link":"/2020/11/06/vscode-search-exclude-setting/"},{"title":"vscode 라인 이동 단축키","text":"Ctrl + G 오류 라인을 갈 때, Ctrl + G 로 마우스 손안대고 이동할 수 있다. Ctrl + rightArrowCtrl + leftArrow Ctrl + left|right arrow key 로 단어단위로 커서를 이동시킬 수 있다.","link":"/2020/11/02/vscode-%EB%9D%BC%EC%9D%B8-%EC%9D%B4%EB%8F%99-%EB%8B%A8%EC%B6%95%ED%82%A4/"},{"title":"vscode 카테고리 생성","text":"갓갓 편집기 vs code에 관한 내용 올리기","link":"/2020/09/18/vscode-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC-%EC%83%9D%EC%84%B1/"},{"title":"typescript json import","text":"tsconfig.json123456&quot;compilerOptions&quot;: { // (...) &quot;resolveJsonModule&quot;: true, &quot;esModuleInterop&quot;: true,} tsconfig.json 의 compilerOptions 부분에 추가한다 참고 Angular 8 and importing Json","link":"/2020/11/10/typescri/"},{"title":"vscode에서 마크다운 미리보기","text":"vscode에서 markdown open preview를 사용하면된다. markdown open preview ctrl shift v 를 누르면 마크다운 미리보기를 할 수 있다. 마크다운 미리보기창이 열리면 ctrl alt →키를 통해 옆으로 옮겨서 볼 수 있다. 실시간으로 반영되니 마크 다운 쓸때 엄청 유용하다!","link":"/2020/09/23/vscode%EC%97%90%EC%84%9C-%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4-%EB%AF%B8%EB%A6%AC%EB%B3%B4%EA%B8%B0/"},{"title":"ubuntu ec2 remote-ssh 튕김","text":"아마존 리눅스는 안튕기는데 ubuntu는 튕긴다… vscode remote - ssh 를 통해 리모트했다. 처음에 연결이 잘되지만 한 1분 정도사용하면 튕긴다.","link":"/2020/10/27/ubuntu-ec2-remote-ssh-%ED%8A%95%EA%B9%80/"},{"title":"vscode 항상 관리자 권한 실행하기","text":"관리자 권한이 필요한 상황이 있는데.. vscode를 항상 관리자 권한으로 실행해보자. 따라하기 윈도우키(검색창) &gt; code 검색 &gt; 우클릭 &gt; 파일 위치 열기 Visual Studio Code 바로가기를 우클릭 &gt; 속성 호환성탭 &gt; 모든 사용자에 대한 설정 변경 &gt; 관리자 권한으로 이 프로그램 실행 체크 &gt; 확인 &gt; 확인 이렇게하면 항상 관리자 권한 상태로 vscode가 실행된다. 사용자 게정 컨트롤 창 없애기 관리자 권한 실행으로 실행할때 나오는 사용자 계정 컨트롤 : 이 앱이 디바이스를 변경할 수 있도록 허용하시겠어요?까지 안나오게 해보자. 윈도우키(검색창) &gt; 사용자 게정 컨트롤 설정 변경 &gt; 알리지 않음 으로 설정 팁 vscode는 관리자권한이 아닌창이 켜져있을 때, 새로이 관리자권한으로 새 창(New Window)을 실행시킬 수 없다. 관리자권한으로 실행중인 vscode 창이 있을 때, 새로이 관리자권한이 아닌 새 창(New Window)을 실행시킬 수 없다. 즉, 처음에 관리자권한으로 실행시키면, 나중에 새로켜는 창은 모두 관리자 권한이여야 한다. 반대로 처음에 관리자권한이 아닌 기본권한으로 실행시키면, 나중에 새로켜는 창은 모두 관리자 권한이 아니다. (주의! : vscode 우클릭 관리자 권한 실행을 하더라도 기본권한으로 실행됨.) 그러므로 vscode 창 상단에 [Administrator] 표시가있는지 확인하자! 관리자권한으로 접근가능한 파일이 계속 접근이 안되서 뭐지 했는데, 이 문제였다.. 결국 켜져있는 모든 vscode창을 종료하고 새로이 관리자권한으로 실행시키니 관리자권한으로 켜졌다.","link":"/2020/10/15/vscode-%ED%95%AD%EC%83%81-%EA%B4%80%EB%A6%AC%EC%9E%90-%EA%B6%8C%ED%95%9C-%EC%8B%A4%ED%96%89%ED%95%98%EA%B8%B0/"},{"title":"vscode 워크스페이스, 프로젝트별로 설정 다르게하기","text":"각 프로젝트 마다 다른 vscode세팅값을 주고 싶을 때 유용하다. 따라하기 Ctrl + Shift + P 단축키를누르고 setting을 입력한다 Preferences: Open Settings (UI)를 선택한다. 세팅화면이 나오면 상단 User, Workspace 탭이 있는데 Workspace탭을 클릭한다. 나는 예시로 이 프로젝트에서는 node_modules라는 폴더를 vscode 탐색기에서 보여주고싶지않다. exclude를 검색하면 Files: Exclude가 나오는데, Add Pattern 버튼을 눌러 node_modules를 추가한다. 우측 탐색기에서 node_modules 파일이 더이상 보이지 않으며, .vscode라는 폴더와 그 아래 settings.json이라는 파일이 생성된 것을 확인 할 수 있다. 이렇게 프로젝트별로 다른 vscode 세팅값을 가질 수 있다.","link":"/2020/11/02/vscode-%EC%9B%8C%ED%81%AC%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EB%B3%84%EB%A1%9C-%EC%84%A4%EC%A0%95-%EB%8B%A4%EB%A5%B4%EA%B2%8C%ED%95%98%EA%B8%B0/"},{"title":"가장 큰 정사각형 찾기","text":"12345678910111213141516171819202122232425262728293031323334353637// https://programmers.co.kr/learn/courses/30/lessons/12905// 가장 큰 정사각형 찾기function solution(board) { var answer = 1; var lownum = board.length; var colnum = board[0].length; console.log(lownum, colnum); if (lownum == 1 || colnum == 1) { var maxRow = board.map(function (row) { return Math.max.apply(null, row); }); var max = Math.max.apply(null, maxRow); return max; } var max = 0; for (var q = 1; q &lt; board.length; q++) { for (var w = 1; w &lt; board[0].length; w++) { if (board[q][w] == 0) { continue; } var arr = [board[q - 1][w - 1], board[q - 1][w], board[q][w - 1]]; board[q][w] = Math.min.apply(null, arr) + 1; max = Math.max(max, board[q][w]); } } answer = max * max; // console.log(maxRow, max); console.log(answer); return answer;} 해설 2차원 배열이 입력으로 들어온다 2차월 연속된 1 이 이루는 가장 큰 정사각형의 넓이를 반환해야 한다 먼저 입력된 보드가 행과 열 어느 하나가 1인 경우 1또는 0을 반환한다. 이제 1이 아닌 경우에 복잡해 지는데.. 0과 1로만 이루어진 보드를 갱신해 나갈거다. board[1][1] 부터 시작해서 이전 3개를 살펴볼것이다. 이때 board[1][1]이 0 이면 패스한다. 1이면 ㄱㄱ 위, 왼쪽, 왼쪽 대각선위를 살펴서 가장 작은 숫자를 찾는다. 그런다음에 board[1][1]에 가장 작은 숫자 + 1을 대입한다 board[1][2] 로 이동해서 같은 것을 반복한다. 그림으로 보면 이렇다. step1] board[1][1] 일때 step1] board[1][2] 일때 반복… 결과] 위 처럼 계속 갱신하고 보드에 마지막에 도달하면 끝이 난다 이후에 board 내에서 가장 높은 숫자를 찾는다. 그러면 3이라는 숫자를 얻을 수 있다. 넓이를 반환하고 했으니까 3*3 해서 9를 반환하면 된다.","link":"/2020/09/18/%EA%B0%80%EC%9E%A5-%ED%81%B0-%EC%A0%95%EC%82%AC%EA%B0%81%ED%98%95-%EC%B0%BE%EA%B8%B0/"},{"title":"web 카테고리 생성","text":"web","link":"/2020/09/18/web-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC-%EC%83%9D%EC%84%B1/"},{"title":"게시판 페이지네이션 SQL","text":"sql123456const page = 1;const query = `SELECT * FROM notice WHERE use_flag='Y' ORDER BY idx DESC LIMIT ?,?`;const queryArgs = [10 * (page - 1), 10];return client.query(query, queryArgs); notice 테이블에서 page값에 따라 게시글 10개를 가져오는 쿼리이다 limit 을 이용해서 구현하였다. SELECT * FROM notice LIMIT 0,10// 0번째부터 10개를 가져온다는 의미이다. SELECT * FROM notice LIMIT 20,10// 20번째부터 10개를 가져온다는 의미이다. 참고 web test에서 사용한 소스코드","link":"/2020/11/09/%EA%B2%8C%EC%8B%9C%ED%8C%90-%ED%8E%98%EC%9D%B4%EC%A7%80%EB%84%A4%EC%9D%B4%EC%85%98-SQL/"},{"title":"windows10 home에서 docker 설치하기","text":"home 버전에서 docker가 설치된다고? windows10 home도 버전 2004로 업데이트하면 가능 bios에서 가상화 설정 wsl 활성화 설치하기 먼저 자신의 윈도우 버전을 확인합니다. win + R 키로 실행창 여시고 winver 실행 2004 버전이 아니라면! 윈도우 업데이트를 열어서 2004 버전 업데이트를 해줍니다. 시간이 쫌 걸린다 이제 BIOS에서 가상화 설정을 활성화를 해줍니다. asus bios 기준 ; 고급 &gt; cpu &gt; 가상화 기술 enable 아마 다른 보드들도 cpu 하위 메뉴에 있을거다. wsl 기능을 활성화 합니다. (재부팅 필요) https://hub.docker.com/editions/community/docker-ce-desktop-windows/ docker 인스톨러 다운받기, get stable 클릭해서 받는다. 인스톨러를 실행한다. 끝","link":"/2020/09/21/windows10-home%EC%97%90%EC%84%9C-docker-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0/"},{"title":"글마다 썸네일 넣기","text":"글마다 썸네일 넣는법! thumbnail: 이미지 경로 12345678910---title: 글마다 썸네일 넣기date: 2020-09-17 13:21:23category: blogtags: - hexo - thumbnailthumbnail: /images/글마다-썸네일-넣기20200917/미리보기.jpg--- 주의사항1&lt;img src=&quot;/images\\글마다-썸네일-넣기20200917\\photo_2020-09-17_13-22-16.jpg&quot; &gt; 포스팅할때 내용에 저런식으로 /와 \\를 혼용해도 정상작동했다.. 그래서 썸네일 지정도 그러할 줄 알았더니… 1thumbnail: /images\\글마다-썸네일-넣기20200917\\미리보기.jpg 이렇게 넣으면 작동을 안한다. 이렇게.. 1thumbnail: /images/글마다-썸네일-넣기20200917/photo_2020-09-17_13-22-16.jpg 이렇게 /로 다 치환해줘야 썸네일 이미지가 제대로 들어간다.","link":"/2020/09/17/%EA%B8%80%EB%A7%88%EB%8B%A4-%EC%8D%B8%EB%84%A4%EC%9D%BC-%EB%84%A3%EA%B8%B0/"},{"title":"깃허브 자기 닉네임 저장소 special repository","text":"https://github.com/chinsun9 자기 깃허브 메인화면에 가장 처음 표시되는 readme파일의 저장소다! 내가 어떤 개발자인지 보여주는 용도이다. GitHub Readme Stats를 통해 자기 깃허브 활동을 시각적으로 보여주면 더 좋다! special repository github에서 저장소명을 자신의 닉네임이랑 똑같이 하면 special repository 라는 것이 만들어진다. 이 special repository는 내 깃허브 메인 화면에서 가장 처음으로 보여지는데, 여기서 내 프로필을 적어서 나를 자랑?할 수 있다. GitHub Readme Stats https://github-readme-stats.vercel.app/api?username={내 깃허브닉네임} https://github-readme-stats.vercel.app/api/top-langs/?username={내 깃허브닉네임} 아무 설치없이 간단하게 내 깃허브 활동 통계를 볼 수 있다..! chinsung/chinsung https://github.com/chinsun9/chinsun9","link":"/2020/10/30/%EA%B9%83%ED%97%88%EB%B8%8C-%EC%9E%90%EA%B8%B0-%EB%8B%89%EB%84%A4%EC%9E%84-%EC%A0%80%EC%9E%A5%EC%86%8C/"},{"title":"내가 블로그에서 마크다운 쓰는법","text":"포스트.md12345678910111213141516171819&lt;img src=&quot;https://chinsun9.github.io/img/avatar.png&quot; &gt;- 상세 설명1- 상세 설명2## h2- 그러하다### h3- 그러하다- 종종 [링크](https://chinsun9.github.io/img/avatar.png)## 코드 스니펫```js tmp.jsconsole.log(hi);``` 나는 블로그에 글 쓸때 이렇게만 쓴다. 위 처럼 작성하면 결과는… 상세 설명1 상세 설명2 h2 그러하다 h3 그러하다 종종 링크 코드 스니펫tmp.js1console.log(hi);","link":"/2020/09/22/%EB%82%B4%EA%B0%80-%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%97%90%EC%84%9C-%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4-%EC%93%B0%EB%8A%94%EB%B2%95/"},{"title":"chrome 강력 새로고침","text":"웹을 수정할때 가끔 브라우저 캐시때문에 원하는 모양이 안나오는 경우가 있다. 강력 새로고침하는 법 F12로 크롬 개발자 도구창을 킨다. 브라우저 상단 새로고침 아이콘에 우클릭을하면 3개의 새로고침 메뉴가 나온다. (개발자 도구창이 안켜져있으면 안나옴) 그밖에도 단축키를 이용하는 방법이 있다.","link":"/2020/10/14/%EA%B0%95%EB%A0%A5-%EC%83%88%EB%A1%9C%EA%B3%A0%EC%B9%A8/"},{"title":"내 github blog 글이 구글 검색에 나오는 법","text":"깃허브 블로그는 네이버 블로그와 같이 자동으로 검색엔진을 통해 검색되지 않는다! 내가 쓴 글이 구글 검색에 노출되려면 설정을 해줘야한다! 따라하기 hexo icarus theme (react) 기준입니다! Hexo SEO - 하루 만에 검색 엔진 최적화 시키기 | Seongho’s Dev Story를 참고하였다 SEO 설정 seo, search engine optimization cmd1234npm i hexo-autonofollownpm i hexo-generator-feednpm i hexo-generator-seo-friendly-sitemapnpm i hexo-generator-robotstxt hexo에서 seo 관련 플러그인이 있는데 설치한다. 참고 ; 다른 seo관련 글에서는 hexo-auto-canonical을 설치하라고 하는데 react로 되어있는 최신버전의 icarus 테마에서는 표준링크을 자동으로 생성한다. 그래서 설치하지 않아도 된다! _config.yml1234567891011121314151617181920212223deploy: type: git repo: 'https://github.com/chinsun9/chinsun9.github.io' branch: master# 새로 추가nofollow: enable: true exclude: - exclude1.com - exclude2.comfeed: type: rss2 path: rss2.xml limit: 20sitemap: path: sitemap.xml tag: false category: falserobotstxt: useragent: '*' allow: - / sitemap: https://chinsun9.github.io/sitemap.xml _config.yml 최 하단에 deploy 설정 밑에 새로 추가한다. sitemap: https://여러분의깃헙유저네임.github.io/sitemap.xml 주의! 나는 위 과정에서 hexo-component-inferno 패키지를 설치하라고 해서 설치했다. 또 패키지 4개를 설치하면서 warn 경고 메시지가 자꾸 출력되는데 나는 무시했다. 여기까지 했다면 hexo d -g명령으로 배포한다. 참고 ; hexo d -g는 hexo deploy --generate명령과 동일하다. 참고 ; hexo deploy --generate는 hexo generate &amp; hexo deploy와 동일하다. 그러면 public 디렉터리에 rss2.xml, sitemap.xml, robots.txt 이 3개의 파일이 보이면 성공이다. 검색 엔진 등록하기구글 구글 서치 콘솔로 이동하여 시작하기를 누른다. URL 접두어를 선택하고, 자신의 깃헙 주소를 입력하고 계속한다. 소유권 확인 과정이 있는데, html 파일을 다운받고, hexo 디렉터리에서 public 디렉터리 밑에 다운받은 파일을 위치시키고 hexo d하려 배포한다. 잠시 기다렸다가 확인버튼을 누른다. 소유권이 확인되면 속성으로 이동 버튼을 누른다. sitemaps 메뉴를 클릭한다 2-1. 사이트맵 URL 입력에 sitemap.xml을 입력하고 제출 버튼을 누른다. 2-2. 사이트맵 URL 입력에 rss2.xml을 입력하고 제출 버튼을 누른다. 상태에 보면 성공이 아닐 수도 있는데 새로고침 해보면 성공으로 보일 것이다. 하루정도? 지나면 구글에서 내 글을 검색할 수 있다! 네이버 네이버도 구글과 비슷하므로 간단하게 넘어간다. 네이버 웹마스터 도구에 들어간다. 사이트 등록에 내 깃헙 블로그 주소를 입력하면 소유권확인 과정이 나온다 구글과 똑같이 html파일을 다운받고 public 디렉터리에 파일을 옮기고 hexo d하여 갱신한다. 왼쪽 메뉴를 보면 요청 &gt; rss제출로 들어가 자신의 rss2.xml 주소를 입력하고 확인버튼을 누른다. 요청 &gt; 사이트맵 제출로 들어가 sitemap.xml을 입력하고 확인버튼을 누른다. 네이버 등록도 끝이 났다! 다음 다음은 약간 다르다 다음 검색등록에 들어간다. 신규등록하기 버튼을 누른다 약관에 동의한다. 폼을 작성한다. * 마크가 붙어있는 것은 필수 항목이다. 심사가 끝나면 이메일로 알려준다고 하니 기다리자.. 여기까지 다음 등록도 끝났다! 팁언제부터 검색이 될까..? 검색 엔진에 등록하면 바로 검색 노출은 안되고, 시간이 필요하다. 하루 정도 걸린다고 생각하자. 표준링크 확인하기 hexo-auto-canonical를 설치하지 않아도 된다고 했는데, 알아보니까 자동으로 생성해주고 있었다! 확인하는 방법은.. 내 블로그에서 아무 글이나 클릭해서 들어간다. F12로 개발자도구를 연다. ctrl f 로 검색창을 연다음에 canonical를 검색한다. 그러면 위와같은 link 태그가 있으면 된다!","link":"/2020/09/23/%EB%82%B4-github-blog-%EA%B8%80%EC%9D%B4-%EA%B5%AC%EA%B8%80-%EA%B2%80%EC%83%89%EC%97%90-%EB%82%98%EC%98%A4%EB%8A%94-%EB%B2%95/"},{"title":"내가 싫어하는 것","text":"싫어하는 것-&gt; 선호하는 것 글자 읽기 : 3줄이상 빼곡히 붙어있는 글자 -&gt; 이미지, 동영상, 오디오 흥미 없는 것 자료조사 또는 공부 -&gt; 관심있는 것 조사 이론 -&gt; 실기 ~하기위한 방법/절차 -&gt; ~을 했을때 결과 예제 좋아하는 것 단순한 것","link":"/2020/10/20/%EB%82%B4%EA%B0%80-%EC%8B%AB%EC%96%B4%ED%95%98%EB%8A%94-%EA%B2%83/"},{"title":"도커 메모리 차지","text":"윽… 도커를 쓰다보면 메모리가 부족해서 마우스가 끊기고 막 그런다… 참고로 나는 윈도우에 8GB램을 쓰고잇다.. 참고 WSL2 기반 docker 사용시 vmmem 프로세스 메모리 소모량 줄이기","link":"/2020/10/16/%EB%8F%84%EC%BB%A4-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%B0%A8%EC%A7%80/"},{"title":"도로명주소 api 사용하기","text":"nodejs express ejs로 웹을 만드는데 도로명 주소 api를 사용하게됬다. 예제가 jsp밖에없어서 헤맸는데.. 따라하기 이미지가 먼저 나오고 설명은 이미지 아래 적습니다! ejs에서 도로명주소 api를 사용하는 법! 간단한 express 프로젝트로 해보자! 준비물 vscode nodejs 도로명 주소 api 키 발급받기 도로명 주소 api 신청하기 신청폼을 작성한다. 서비스폼은 개발로 선택하면 별도 인증없이 발급받을 수 있다. 공부할때 딱이다! 신청 버튼을 누르고 나면, 빨간색 폰트로 승인키가 보일것이다. 승인키를 복사하여 메모해둔다! express generator로 프로젝트 생성 여기부터 vscode을 열고 작업합니다. cmd1npm i express-generator -g express-generator를 전역설치한다. cmd1express juso-api-practice --view=ejs cmd log12345678change directory: &gt; cd juso-api-practiceinstall dependencies: &gt; npm installrun the app: &gt; SET DEBUG=juso-api-practice:* &amp; npm start 이런 메시지가 나오면 성공한거다 메시지 대로 수행해보자 cmd123cd juso-api-practicenpm iSET DEBUG=juso-api-practice:* &amp; npm start cmd log123456C:\\tmp\\juso-api-practice&gt;SET DEBUG=juso-api-practice:* &amp; npm start&gt; juso-api-practice@0.0.0 start C:\\tmp\\juso-api-practice&gt; node ./bin/www juso-api-practice:server Listening on port 3000 +0ms 여기까지 되면 http://localhost:3000/ 에 접속해서 잘 실행되는지 확인한다. 주소 입력할 폼 만들기 jsp 소스를 참고하여 만들었다. view/index.ejs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/stylesheets/style.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt; &lt;p&gt;Welcome to &lt;%= title %&gt;&lt;/p&gt; &lt;div&gt; &lt;form name=&quot;form&quot;&gt; &lt;input name=&quot;roadAddrPart1&quot; type=&quot;text&quot; placeholder=&quot;도로명주소&quot; /&gt; &lt;input name=&quot;addrDetail&quot; type=&quot;text&quot; placeholder=&quot;고객입력 상세주소&quot; /&gt; &lt;input name=&quot;zipNo&quot; type=&quot;text&quot; placeholder=&quot;우편번호&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;주소검색&quot; onclick=&quot;goPopup()&quot; /&gt; &lt;/form&gt; &lt;/div&gt; &lt;script language=&quot;javascript&quot;&gt; function goPopup() { var pop = window.open( '/popup/jusoPopup', 'pop', 'width=570,height=420, scrollbars=yes, resizable=yes' ); } function jusoCallBack( roadFullAddr, roadAddrPart1, addrDetail, roadAddrPart2, engAddr, jibunAddr, zipNo, admCd, rnMgtSn, bdMgtSn, detBdNmList, bdNm, bdKdcd, siNm, sggNm, emdNm, liNm, rn, udrtYn, buldMnnm, buldSlno, mtYn, lnbrMnnm, lnbrSlno, emdNo ) { // 팝업페이지에서 주소입력한 정보를 받아서, 현 페이지에 정보를 등록합니다. document.form.roadAddrPart1.value = roadAddrPart1; document.form.addrDetail.value = addrDetail; document.form.zipNo.value = zipNo; } &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; view/index.ejs를 위 소스로 덮어쓴다. 이제 새로운 view파일을 만든다. 도로명 주소 검색 팝업용 view파일 생성view/jusoPopup.ejs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;% const { inputYn, roadFullAddr, roadAddrPart1, roadAddrPart2, engAddr, jibunAddr, zipNo, addrDetail, admCd, rnMgtSn, bdMgtSn, detBdNmList, bdNm, bdKdcd, sggNm, emdNm, rn, udrtYn, buldMnnm, buldSlno, mtYn, lnbrMnnm, lnbrSlno, emdNo, siNm, liNm, } = locals; %&gt; &lt;/head&gt; &lt;script language=&quot;javascript&quot;&gt; // document.domain = 'localhost'; function init() { var url = location.href; var confmKey = 'devU01TX0FVVEgyMDIwMDkyMzE0NDY0NjExMDIyNDQ='; var resultType = '4'; // 도로명주소 검색결과 화면 출력내용, 1 : 도로명, 2 : 도로명+지번, 3 : 도로명+상세건물명, 4 : 도로명+지번+상세건물명 var inputYn = '&lt;%=inputYn%&gt;'; if (inputYn != 'Y') { document.form.confmKey.value = confmKey; document.form.returnUrl.value = url; document.form.resultType.value = resultType; document.form.action = 'http://www.juso.go.kr/addrlink/addrLinkUrl.do'; //인터넷망 //document.form.action=&quot;http://www.juso.go.kr/addrlink/addrMobileLinkUrl.do&quot;; //모바일 웹인 경우, 인터넷망 document.form.submit(); } else { opener.jusoCallBack( '&lt;%=roadFullAddr%&gt;', '&lt;%=roadAddrPart1%&gt;', '&lt;%=addrDetail%&gt;', '&lt;%=roadAddrPart2%&gt;', '&lt;%=engAddr%&gt;', '&lt;%=jibunAddr%&gt;', '&lt;%=zipNo%&gt;', '&lt;%=admCd%&gt;', '&lt;%=rnMgtSn%&gt;', '&lt;%=bdMgtSn%&gt;', '&lt;%=detBdNmList%&gt;', '&lt;%=bdNm%&gt;', '&lt;%=bdKdcd%&gt;', '&lt;%=siNm%&gt;', '&lt;%=sggNm%&gt;', '&lt;%=emdNm%&gt;', '&lt;%=liNm%&gt;', '&lt;%=rn%&gt;', '&lt;%=udrtYn%&gt;', '&lt;%=buldMnnm%&gt;', '&lt;%=buldSlno%&gt;', '&lt;%=mtYn%&gt;', '&lt;%=lnbrMnnm%&gt;', '&lt;%=lnbrSlno%&gt;', '&lt;%=emdNo%&gt;' ); window.close(); } } &lt;/script&gt; &lt;body onload=&quot;init();&quot;&gt; &lt;form id=&quot;form&quot; name=&quot;form&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; id=&quot;confmKey&quot; name=&quot;confmKey&quot; value=&quot;&quot; /&gt; &lt;input type=&quot;hidden&quot; id=&quot;returnUrl&quot; name=&quot;returnUrl&quot; value=&quot;&quot; /&gt; &lt;input type=&quot;hidden&quot; id=&quot;resultType&quot; name=&quot;resultType&quot; value=&quot;&quot; /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 이 jusoPopup.ejs 가 index view에서 버튼을 누르면 등장하는 팝업이다. view/jusoPopup.ejs 이름으로 만든다 이제 라우터를 수정하자 api가 잘 동작하도록 라우터 수정routes/index.js123456789101112131415161718var express = require('express');var router = express.Router();/* GET home page. */router.get('/', function (req, res, next) { res.render('index', { title: 'Express' });});router.get('/popup/jusoPopup', (req, res) =&gt; { res.render('jusoPopup');});router.post('/popup/jusoPopup', (req, res) =&gt; { res.locals = req.body; res.render('jusoPopup');});module.exports = router; routes/index.js를 위 소스로 덮어쓴다. /popup/jusoPopup 라우트를 추가해줬다. 동작 구조 설명 그림으로 표현해봤다.. 그리고보니 엄청 더럽네.. jusoPopup.ejs는 2가지 일을하는 놈이다. 도로명주소 검색창을 보여주거나, 입력폼으로 도로명주소 결과를 전달한다. inputYn 이라는 변수가 있는데, 이 변수에 따라 동작 여부가 갈린다. index화면에서 주소검색 버튼을 눌러 켜면 get으로 주소팝업을 불러온다. 그러면 inputYn 변수가 초기화 되지 않아있다. http://www.juso.go.kr/addrlink/addrLinkUrl.do 로 자동으로 도로명주소 api를 통해 검색화면을 불러온다. 사용자가 검색화면에서 검색어를 입력하면 http://www.juso.go.kr/addrlink/addrLinkUrlSearch.do 로 도로명주소 api를 통해 검색결과를 받아온다. 결과중 하나를 선택하고 상세주소를 입력하고 마지막으로 주소입력 버튼을 누르면, post로 주소팝업을 불러온다. 이때 검색결과를 같이 넘긴다. post로 주소팝업을 부르면 라우터에서는 수신받은 검색결과를 다시 리스폰객체에 담아서 보내준다. 그러면 inputYn 변수가 초기화 되어있다. inputYn가 Y 일때, 부모창(index.ejs)에 jusoCallBack()함수를 실행시키는데, 이때 인자로 검색결과를 넘기는 것이다. 그러면 index.ejs의 jusoCallBack()에서 검색결과값을 가지고 인풋을 덮었는 것이다. 여기까지 프로젝트 소스참고 도로명주소api를 활용한 웹 프로젝트","link":"/2020/09/23/%EB%8F%84%EB%A1%9C%EB%AA%85%EC%A3%BC%EC%86%8C-api-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"title":"로컬에서 sam 테스트하기","text":"이제 테스트할 때 build, deploy 기다리기… 할 필요가 없다! 전제조건 docker 설치 참고 ; windows10 home에서 docker 설치하기 지난번에 만든 hello-world sam project에서 테스트해보자 sam local start-apicmd1sam local start-api --skip-pull-image cmd log123456789101112131415161718C:\\tmp\\hello-world&gt;sam local start-api --skip-pull-imageMounting HelloWorldFunction at http://127.0.0.1:3000/hello [GET]You can now browse to the above endpoints to invoke your functions. You do not need to restart/reload SAM CLI while working on your functions, changes will be reflected instantly/automatically. You only need to restart SAMCLI if you update your AWS SAM template2020-09-21 13:40:36 * Running on http://127.0.0.1:3000/ (Press CTRL+C to quit)2020-09-21 13:40:41 127.0.0.1 - - [21/Sep/2020 13:40:41] &quot;GET / HTTP/1.1&quot; 403 -2020-09-21 13:40:41 127.0.0.1 - - [21/Sep/2020 13:40:41] &quot;GET /favicon.ico HTTP/1.1&quot; 403 -Invoking app.lambdaHandler (nodejs12.x)Requested to skip pulling images ...Mounting C:\\tmp\\hello-world\\.aws-sam\\build\\HelloWorldFunction as /var/task:ro,delegated inside runtime containerSTART RequestId: 00b5b190-1c8d-184f-5ab5-c0e0764041d3 Version: $LATESTEND RequestId: 00b5b190-1c8d-184f-5ab5-c0e0764041d3REPORT RequestId: 00b5b190-1c8d-184f-5ab5-c0e0764041d3 Init Duration: 438.88 msDuration: 4.53 ms Billed Duration: 100 ms Memory Size: 128 MB Max Memory Used: 44 MBNo Content-Type given. Defaulting to 'application/json'.2020-09-21 13:40:48 127.0.0.1 - - [21/Sep/2020 13:40:48] &quot;GET /hello HTTP/1.1&quot; 200 -2020-09-21 13:40:48 127.0.0.1 - - [21/Sep/2020 13:40:48] &quot;GET /favicon.ico HTTP/1.1&quot; 403 - 나는 이렇게 명령을 쓴다. 나는 보통 매 실행마다 3-4초 정도 걸린다. build, deploy 하면서 테스트할때보다 획기적으로 빠르게 로컬에서 테스트 해볼 수 있다. --skip-pull-image옵션을 주는 이유는 매 실행마다 이미지를 받아오는 과정이 있는게 그걸 스킵하면 2초정도 빨라진다. 변경 사항은 자동으로 반영된다. 단점 ; 근데 변경사항이 없어도 매 실행 3초이상 걸린다. template.yaml 파일을 수정하면 수동으로 재시작 해줘야한다.","link":"/2020/09/21/%EB%A1%9C%EC%BB%AC%EC%97%90%EC%84%9C-sam-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EA%B8%B0/"},{"title":"리눅스에서 특정 포트를 사용하는 프로세스 확인하기","text":"terminal123lsof -i:8080kill -9 $(lsof -t -i:8080) ps -ef|grep node 이런식으로 node로 실행한 웹서버를 확인했었는데, node로 실행한 많은 앱이 있을때 어떤게 내가 생각하는 앱인지 헷갈릴때가 있다. 이럴때 특정 포트를 사용하는 프로세스를 어떻게 검색할까 하다가 알아보았다. lsofterminal1lsof -i:3000 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEnode 13721 ec2-user 18u IPv6 389226 0t0 TCP *:hbci (LISTEN) 이런식으로 해당 포트를 사용하는 프로세스를 확인할 수 있다. terminal1lsof -t -i:3000 13721 -t옵션을 추가하면 pid만 깔끔하게 얻을 수 있어 kill -9 $(lsof -t -i:3000) 이런식으로 묶어서 사용할 수 있다. 참고 https://stackoverflow.com/questions/11583562/how-to-kill-a-process-running-on-particular-port-in-linux","link":"/2020/11/03/%EB%A6%AC%EB%88%85%EC%8A%A4%EC%97%90%EC%84%9C-%ED%8A%B9%EC%A0%95-%ED%8F%AC%ED%8A%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0/"},{"title":"도커 실행 명령어","text":"1sudo service docker start sudo service docker start ec2 리눅스에서 도커 실행할때 주로 쓴다 윈도우에서는 그냥 docker desktop을 실행시킨다","link":"/2020/10/23/%EB%8F%84%EC%BB%A4-%EC%8B%A4%ED%96%89-%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"title":"마크다운에서 유튜브 동영상 삽입하기","text":"와우… 1[![미리보기](https://img.youtube.com/vi/J3kUYFFdVc0/0.jpg)](https://www.youtube.com/watch?v=J3kUYFFdVc0) 이렇게 힘들게 쎃었는데… 태그 플러그인 전문 용어로 태그 플러그인이라고 한다. 1{% youtube ycg_Cuse0M4 %} 이렇게 간단하게 사용한다 주의! 순수 마크다운이 아니다! hexo 에서 지원하는 기능이다..","link":"/2020/09/17/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4%EC%97%90%EC%84%9C-%EC%9C%A0%ED%8A%9C%EB%B8%8C-%EB%8F%99%EC%98%81%EC%83%81-%EC%82%BD%EC%9E%85%ED%95%98%EA%B8%B0/"},{"title":"마크다운에서 이미지 표시하는 법","text":"md1234![](/img/avatar20200926.png)&lt;img src=&quot;&quot; &gt;&lt;!-- 더이상 이거 안써도된다. --&gt; ![]() 이게 훨씬 간편한 것 같다.","link":"/2020/10/13/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4%EC%97%90%EC%84%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%ED%91%9C%EC%8B%9C%ED%95%98%EB%8A%94-%EB%B2%95/"},{"title":"바로 직전 커밋 취소","text":"12345git reset --soft &quot;HEAD^&quot;또는git reset --soft HEAD~1 이렇게하면 파일 상태는 그대로 이며 직전 커밋내역만 없어진다. 나는 빠진 파일을 추가하거나 커밋 메시지를 다시 작성할 때 쓴다. more? git reset asks ‘more?’ more? 이라는 문구가 나와서 당황했는데 “ “으로 감싸주면된다.","link":"/2020/10/18/%EB%B0%94%EB%A1%9C-%EC%A7%81%EC%A0%84-%EC%BB%A4%EB%B0%8B-%EC%B7%A8%EC%86%8C/"},{"title":"마크다운에서 코드 표시하는 법","text":"example.js\"링크도 걸 수 있네\"12let message = '로그를 찍는 코드';console.log(message); 정말 쓸일이 많다. 블로그를 한다면.. .md에서 코드 블럭 표시하기","link":"/2020/09/17/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4%EC%97%90%EC%84%9C-%EC%BD%94%EB%93%9C-%ED%91%9C%EC%8B%9C%ED%95%98%EB%8A%94-%EB%B2%95/"},{"title":"멋진 깃허브 블로그 시작하기","text":"나도 멋진 깃허브 블로그를 만들어보고 싶었다. (지금 이 블로그!) Hexo 라는 블로그 프레임워크가 있었다. 한글로 된 공식 문서도 있어서 접근하기 좋았다. 나는 카인드패밀리님의 영상을 보고 따라하면서 만들어 보았다. Hexo를 이용하면 멋진 블로그를 뚝딱하고 만들 수 있다. 간단하게 설명하자면, Hexo에서 원하는 테마를 받아와서 글을 쓰고, 내 github.io 저장소와 연결하고 배포하는 거다. 따라하기 먼저 nodejs와 git이 설치되어 있어야 한다. 또, https://chinsun9.github.io/ 와 같은 url을 얻고싶으면 {자기 깃허브 아이디}.github.io이름의 저장소가 있어야한다. 준비되었다면 cmd를 열고 hexo cli를 전역으로 설치한다. 나는 vscode에서 터미널을 열어서 진행했다. vscode가 최고다. 1npm i hexo-cli -g hexo 프로젝트 생성 적당한 빈 디렉터리로 이동한다음에 아래 명령어를 실행한다. 혹시 다른 테마를 적용하길 원하는 사람은 테마 적용방법을 찾아 보기 바란다. 여기선 icarus를 설명한다. 12hexo initnpm i hexo-theme-icarus 다음엔 icarus테마를 위한 config를 생성한다 1hexo config theme icarus 12345678INFO Validating configERROR { err: [Error: EISDIR: illegal operation on a directory, read] { errno: -4068, code: 'EISDIR', syscall: 'read' }} Plugin load failed: %s hexo-theme-icarus 위 같은 오류가 나면 무시하고 다시 명령을 실행한다 1hexo config theme icarus 1234567INFO === Checking package dependencies ===ERROR Package bulma-stylus is not installed.ERROR Package hexo-renderer-inferno is not installed.ERROR Please install the missing dependencies your Hexo site root directory:ERROR npm install --save bulma-stylus@0.8.0 hexo-renderer-inferno@^0.1.3ERROR or:ERROR yarn add bulma-stylus@0.8.0 hexo-renderer-inferno@^0.1.3 그러면 다른 오류메시지가 나온다. 이러이러한 패키지가 필요하다하면 추가로 설치해준다. 1npm install --save bulma-stylus@0.8.0 hexo-renderer-inferno@^0.1.3 현재까지 설치된 패키지 목록 1234567891011121314151617&quot;hexo&quot;: { &quot;version&quot;: &quot;5.2.0&quot;},&quot;dependencies&quot;: { &quot;bulma-stylus&quot;: &quot;^0.8.0&quot;, &quot;hexo&quot;: &quot;^5.0.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^1.0.0&quot;, &quot;hexo-generator-category&quot;: &quot;^1.0.0&quot;, &quot;hexo-generator-index&quot;: &quot;^2.0.0&quot;, &quot;hexo-generator-tag&quot;: &quot;^1.0.0&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^1.0.0&quot;, &quot;hexo-renderer-inferno&quot;: &quot;^0.1.3&quot;, &quot;hexo-renderer-marked&quot;: &quot;^3.0.0&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^2.0.0&quot;, &quot;hexo-server&quot;: &quot;^2.0.0&quot;, &quot;hexo-theme-icarus&quot;: &quot;^4.0.1&quot;} 종속성이 해결되면 다시 실행 1hexo config theme icarus 123456789INFO === Checking package dependencies ===INFO === Checking theme configurations ===WARN None of the following configuration files is found:WARN - C:\\git\\tmp blog\\_config.icarus.ymlWARN - C:\\git\\tmp blog\\node_modules\\hexo-theme-icarus\\_config.ymlINFO Generating theme configuration file...INFO C:\\git\\tmp blog\\_config.icarus.yml created successfully.INFO To skip configuration generation, use &quot;--icarus-dont-generate-config&quot;.INFO === Registering Hexo extensions === 위처럼 메시지가 나오면 성공이다. 이제 최상위 디렉터리에 _config.yml 이라는 파일이 있는데 아래 처럼 수정한다. 블로그가 될 저장소 주소를 적어준다. 12345theme: icarusdeploy: type: git repo: https://github.com/chinsun9/chinsun9.github.io branch: master 여기까지 성공적으로 됬다면 로컬에서 확인해 볼 수 있다. 1hexo server -p 3000 새 포스트를 써보자 1hexo new &quot;타이틀&quot; log1234INFO === Checking package dependencies ===INFO === Checking theme configurations ===INFO === Registering Hexo extensions ===INFO Created: C:\\git\\2020-github-pages-hexo\\source\\_posts\\new-post20200916.md 위와같은 메시지가 나오는데 vscode터미널같은 경우 ctrl+click을 통해 바로 저 파일을 열어 볼 수 있다. 열어서 열심히 md 언어로 포스팅을 하고 저장한다. 이제 배포를 해보겠다. hexo-deployer-git을 설치한다. 12npm i hexo-deployer-git -g` 그러면 다음 명령어를 사용할 수 있다 12hexo generatehexo deploy 위처럼 명령어를 두번쓰기 귀찮아서 명령어 하나로 묶어 버렸다. 하는 김에 hexo 커밋까지.. 123456789// package.json &quot;scripts&quot;: { &quot;build&quot;: &quot;hexo generate&quot;, &quot;clean&quot;: &quot;hexo clean&quot;, &quot;deploy&quot;: &quot;hexo deploy&quot;, &quot;test&quot;: &quot;hexo server&quot;, &quot;start&quot;: &quot;hexo generate &amp; hexo deploy &amp; git add . &amp; git commit -m &quot; }, 글을 하나 쓰고 나면 npm start 명령어로 배포하고 커밋한다.npm start &quot;커밋메시지&quot; 이런식으로 써서 편하게? 관리하려고 했다.","link":"/2020/09/16/%EB%A9%8B%EC%A7%84-%EA%B9%83%ED%97%88%EB%B8%8C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"블로그 썸네일 바꾸기","text":"흠… 내 블로그 링크를 걸었는데 이상한 로고가 나온다! \\public\\img\\og_image.png 위치에 있는 이미지를 바꾸면 됩니다. 이 사이트를 대표하는 이미지를 og:image라고 하는 것도 알게 되었다. https://www.opengraph.xyz/ 이 사이트에 자기 블로그 주소를 입력하면 og image가 잘 갱신되었는지 확인 할 수 있다! 아무 이미지도 안나올 때…_config.yml123456789101112title: 친성의 블로그subtitle: '최고의'description: '친성의 개발 블로그'keywords: - dev - developer - coding - swauthor: chinsunglanguage: kotimezone: 'Asia/Seoul'url: 'https://chinsun9.github.io/' url에 자신의 블로그 주소를 넣습니다. _config.yml1url: 'https://chinsun9.github.io/'","link":"/2020/09/17/%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%8D%B8%EB%84%A4%EC%9D%BC-%EB%B0%94%EA%BE%B8%EA%B8%B0/"},{"title":"모의고사","text":"모의고사12345678910111213141516171819202122// https://programmers.co.kr/learn/courses/30/lessons/42840function solution(answers) { const a = [1, 2, 3, 4, 5]; const b = [2, 1, 2, 3, 2, 4, 2, 5]; const c = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5]; let count = [0, 0, 0]; answers.forEach((element, index) =&gt; { a[index % a.length] == element ? count[0]++ : null; b[index % b.length] == element ? count[1]++ : null; c[index % c.length] == element ? count[2]++ : null; }); let result = []; let max = Math.max.apply(null, count); count.forEach((item, idx) =&gt; { if (max == item) { result.push(idx + 1); } }); return result;}solution([1, 2, 3, 4, 5]); 해설 입력으로 정답 배열이 들어온다. a,b,c 세 사람이 있다. 사람마다 찍기 타입이 있다. 각자 자신만의 패턴으로 문제를 찍었을때 가장 문제를 많이 맞힌 사람을 반환한다 일단 찍기타입을 정의하고, 각 사람마다 정답이면 카운트를 늘린다! 나머지 연산으로 패턴을 지속한다. c[index % c.length] 그 중에서 가장 많이 맞춘 사람 배열을 반환한다. (1~다수)","link":"/2020/09/18/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC/"},{"title":"블로그 이미지 업데이트","text":"favicon logo avatar","link":"/2020/09/28/%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8/"},{"title":"소수 찾기","text":"소수 찾기123456789101112131415161718192021222324252627282930// https://programmers.co.kr/learn/courses/30/lessons/12921function solution(n) { var answer = 0; let sosu = []; let arr = {}; for (let i = 2; i &lt;= n; i++) { arr[i] = 1; } for (let index = 2; index &lt;= n; index++) { const element = arr[index]; if (element == 0) { console.log('index', index); continue; } sosu.push(index); let a = 2; // 지금 현재 값을 while (true) { if (!(arr[index * a] + 1)) { break; } arr[index * a++] = 0; console.log(index * a); } } console.log('소수:', sosu); return sosu.length;}result = solution(10); 효율성 통과하기 어려웠다.. 해설 정수 n을 입력받으면 1부터 n 사이의 소수의 개수를 반환한다 효율성을 통과할려면 에라토스테네스의 체를 써야한다. 에라토스테네스의 체 알고리즘을 구현한다. 글로 적힌거 봣는데 하나도 이해가 안되서, 위 그림을 보고 구현했다. (역시 그림이 최고!) 첫번째 반복문에서 2부터 n까지 1로 초기화한다 이제 2부터 n까지 반복문을 돈다 처음에 2는 소수다. 소수 배열에 추가하고 while루프에서 arr배열에서 2의 2배수를 전부 지운다. 여기서 지운다는 것은 arr[2의배수] = 0 으로 만드는 것! 그러면 다음 루프 3… 똑같이한다 그다음 4에서 arr[4] == 0 이기때문에 바로 패스한다. … 반복 내 글로된 설명보다 그림보는게 훨씬 이해에 빠를것이다! 에라토스테네스의 체 소수를 찾는 방법","link":"/2020/09/18/%EC%86%8C%EC%88%98-%EC%B0%BE%EA%B8%B0/"},{"title":"예산","text":"예산1234567891011121314151617181920// https://programmers.co.kr/learn/courses/30/lessons/12982function solution(d, budget) { let answer = 0; d = d.sort((a, b) =&gt; a - b); console.log(d); let count; for (count = 0; count &lt; d.length; count++) { const element = d[count]; budget -= element; if (budget &lt; 0) { break; } else if (budget == 0) { count++; break; } } answer = count; return answer;}result = solution([1, 3, 2, 5, 4], 9); 해설 각 부서의 요구 금액 배열과 예산이 인풋으로 들어온다. 최대한 많은 부서에게 지원하는 경우, 그 부서의 개수를 구해 리턴한다. 먼저 배열을 오름차순으로 정렬한다 배열 앞에서 부터 하나씩 지원해주면서 예산을 깐다. 카운트++ 한다 그러다가 예산이 요구하느 금액보다 작아 지원을 못해주는 경우 break한다. 현재까지 count를 반환한다.","link":"/2020/09/18/%EC%98%88%EC%82%B0/"},{"title":"심볼릭 링크 만들기","text":"동기화 하고 싶은 폴더가 있을때 정말 좋다. 심볼릭 링크 만드는 법 mklink /d [링크이름] [실제위치] 링크이름 ; 새로만들어질 폴더 ; 현재 존재하지 않는 폴더여야 함. 실제위치 ; 원본 폴더 ; 이미 만들어져 있는 폴더 심볼릭 링크 폴더 내용물이 공유된다. (사본이 아님) 링크 폴더도 실제 폴더 처럼 작동한다. 바로가기 아이콘을 하고 있다. 원본 폴더에 별명을 지어준 느낌이다. 포인터 같은 느낌이다. 팁 권한이 없다고 하면 관리자 권한으로 명령을 실행한다. 상대경로를 사용해 만든경우 당연한 말이지만 원본 폴더나 링크 폴더의 위치가 바뀌면 안된다. 디렉터리 구조가 변하지 않고 두 폴더를 이동한다면 잘 작동한다. 절대경로를 사용해 만든경우 링크 폴더를 아무렇게나 이동시켜도 잘 작동한다. 당연한 말이지만 원본 폴더를 옮기면 작동하지 않는다. 내가 활용한 곳aws lambda layer lambda 에서는 함수의 크기를 줄이기 위해 layer라는 것을 사용한다. sam project에서 lambda를 작성하고 node_modules 같은 무거운 얘들은 layer로 빼야한다. 그런데 이 과정이 매우 귀찮다. package.json 에서 종속성들이 빌드되지 않게 주석 sam yaml에서 지정한 종속성 경로에 node_modules 사본 또는 옮기기 수정작업할때, 코딩할때 자동완성 및 문서를 보기 위해서는 node_modules 폴더가 함수 안에 필요함. sam yaml에서 지정한 종속성 경로는 함수안이 되면 안됨. 즉, 직접 다이렉트로 node_modules를 지정할 수 없음. sam project 루트로 빼던가 해야함. 여기서 심볼릭 링크를 활용해서 두 폴더간 동기화를 진행!","link":"/2020/09/17/%EC%8B%AC%EB%B3%BC%EB%A6%AD-%EB%A7%81%ED%81%AC-%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"title":"완주하지 못한 선수","text":"완주하지 못한 선수12345678910111213// https://programmers.co.kr/learn/courses/30/lessons/42576const solution = (participant, completion) =&gt; { let objComletion = {}; completion.forEach((item) =&gt; { !objComletion[item] ? (objComletion[item] = 1) : objComletion[item]++; }); for (let i = 0; i &lt; participant.length; i++) if (!objComletion[participant[i]] || --objComletion[participant[i]] &lt; 0) return participant[i];};result = solution(['leo', 'kiki', 'eden'], ['eden', 'kiki']); 효율성때문에 골치 아픈 문제 해설 solution(['leo', 'kiki', 'eden'], ['eden', 'kiki']) 이런식으로 이름이 들어간 2개의 배열이 들어온다. 첫번째 배열은 참가자명단이고 두번째 배열은 완주자명단이다 완주하지 못한 사람을 반환하면 된다. 그런데 동명이인이 있을 수 있다. 중첩 반복문으로 풀다가 효율성에서 실패했다. 해쉬를 써서 풀라는데, 그러다 생각한데 객체를 만들어서 접근하는 방식이다.. objComletion라는 객체를 하나 생성하고 반복분으로 objComletion.사람이름 으로 초기화한다. 초기화할때 멤버가 없으면 1로 초기화하고 이미 존재하면 ++해서 동명이인 처리를 했다. participant(참가자) 배열로 반목문을 돌면서 사람이름으로 다이렉트로 접근하니까 효율성이 엄청 좋아졌다. 멤버가 없거나, 0일경우 완주하지 못한 선수를 잡아낼 수 있다. 잡담 이 문제 풀면서 겉멋 코드에 맛들려서 안쓰던 화살표 함수도 쓰고… 변수명 &amp;, _ 이런거도 써봤다..ㅋㅋ 효율성 획기적으로 줄여서 기분이 좋았다.","link":"/2020/09/18/%EC%99%84%EC%A3%BC%ED%95%98%EC%A7%80-%EB%AA%BB%ED%95%9C-%EC%84%A0%EC%88%98/"},{"title":"약수의 합","text":"1234567891011121314151617181920212223// https://programmers.co.kr/learn/courses/30/lessons/12928function solution(n) { if (n == 0 || n == 1) { return n; let arr = [1, n]; console.log(Math.sqrt(n)); for (let index = 2; index &lt;= Math.sqrt(n); index++) { if (n % index == 0) { arr.push(index); if (index == Math.sqrt(n)) { } else { arr.push(n / index); } } } console.log(arr); return arr.reduce((prev, curr) =&gt; { console.log(prev, curr); return curr + prev; }, 0);}result = solution(12); //28 해설 정수를 입력받으면 모든 약수의 합을 반환한다 0, 1인 경우 바로 반환한다 무조건 약수인 1과 자기자신으로 약수가 저장될 배열을 초기화한다 2부터 n의 제곱근까지 반복문을 돌면서 나누어 떨어지는지 판단한다 나누어 떨어지면 약수 배열에 추가한다. 약수는 항상 세트로 존재하기 때문에, 제곱근의 경우가 아니라면 n / index 도 약수로 추가한다. reduce로 약수배열의 합을 구한다.","link":"/2020/09/18/%EC%95%BD%EC%88%98%EC%9D%98-%ED%95%A9/"},{"title":"윈도우10에서 클립보드 사용하기","text":"복사를 여러개 해둘 수 있다. 꿀 단축키 Win + V Win + V 키를 누르면 클립보드 창이 나온다. 아마 이 기능을 처음 사용한다면, 클립보드를 시작할 것인지 물어보는데 버튼을 눌러 시작할 수 있다. Ctrl + C 나 Print Screen키를 누를때마다 클립보드에 새로이 추가된다.","link":"/2020/10/06/%EC%9C%88%EB%8F%84%EC%9A%B010%EC%97%90%EC%84%9C-%ED%81%B4%EB%A6%BD%EB%B3%B4%EB%93%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"title":"유용한 탐색기 explorer 단축키","text":"클릭 클릭해서 바꿨었는데, 이제는 단축키로.! 탐색기를 돌아다니다보면 보기옵션이 이상해서 보기힘들다. Ctrl + Shift + [12345678] 나는 주로 ctrl shift 6 인 자세히 옵션을 주로 이용한다. 1~8까지 옵션이 있다.","link":"/2020/10/21/%EC%9C%A0%EC%9A%A9%ED%95%9C-%ED%83%90%EC%83%89%EA%B8%B0-explorer-%EB%8B%A8%EC%B6%95%ED%82%A4/"},{"title":"일렉트론으로 OBS input overlay 클론코딩","text":"오버워치 강의 영상을 보다가 영상속 키보드 마우스 뷰어? 를 가끔 보았었다. 일단 깔끔한 키보드 뷰어로 흥미가 생겼었는데 찾아보니까 OBS input overlay라는 OBS 전용 플러그인이었다. 일렉트론이라는 프레임워크를 사용하여 html, css, js로 데스크탑앱으로 만들어보았다. 신경쓴 것글로벌 키 훅? 내가 만든 앱 밖에서 키가 눌리고 떼지는걸 알아야한다. index.js12345const ioHook = require('iohook');ioHook.on('keydown', (event) =&gt; { mainWindow.webContents.send('keydown', event.rawcode);}); iohook 패키지를 사용해서 해결하게되었다. 그런데 iohook이 최신버전의 일렉트론에서 실행이 안되어서 일렉트론 8.x버전으로 낮추어 진행하게되었다. overlay window 오버레이화면에 마우스 클릭이 되지 않도록 했다. 오버레이화면이 프레임을 가지지 않도록 했다 오버레이화면이 모니터 크기를 구하여 우측하단에 생기도록 하였다. (여러 해상도 대응) 일렉트론 웹을 만든느 기술로 데스크탑앱을 만들 수 있게해주는 마법이다. 나는 요즘 js만 해왔기때문에 일렉트론에 대해 찾아보았다. 일렉트론으로 만들어진 대표적인 앱으로는 비쥬얼 스튜디오 코드가 있다. 일렉트론 시작 Create Desktop App + Installer with HTML/CSS/JS - Electron Tutorial 2020 유튜브를 보며 시작했다 create-electron-app 를 통해 express-generator 처럼 빠르게 프로젝트를 시작할 수 있다. electron-builder 를 통해 배포용 setup 파일을 생성할 수 있다. 소스코드 ; https://github.com/chinsun9/electron-practice 일렉트론 단점? 엄청나게 간단한 앱일지라도 nodejs + Chromium 조합으로 용량이 상당히크다. 소스코드 Input Overlay (Electron)","link":"/2020/11/05/%EC%9D%BC%EB%A0%89%ED%8A%B8%EB%A1%A0%EC%9C%BC%EB%A1%9C-OBS-input-overlay-%ED%81%B4%EB%A1%A0%EC%BD%94%EB%94%A9/"},{"title":"정규식 : 특정 문자열을 포함하는 줄, 라인 판단","text":"상황log1234567&quot;GET / HTTP/1.1&quot; 200 hello world 1&quot;GET / HTTP/1.1&quot; 200 hello world 2&quot;GET /a HTTP/1.1&quot; 404 hello world 1&quot;POST / HTTP/1.1&quot; 404 hello world 1&quot;GET / HTTP/1.1&quot; 200 hello world 2&quot;GET / HTTP/1.1&quot; 200 hello world 1&quot;POST /asd HTTP/1.1&quot; 404 hello world 2 이런 웹 로그가 있다고 하자. 중간에 보이는 200, 404 는 status code 이다. 404 에러인 라인만 뽑아서 보고싶을 때.. 로그파일을 한줄씩 읽으며 정규식으로 확인하기app.ts 전체코드1234567891011121314151617181920212223242526272829303132333435363738394041424344import * as fs from 'fs';import * as path from 'path';import * as readline from 'readline';const input_log_file_name = 'nohup20201107.out';const input_file_path = path.join( __dirname, `../input files/${input_log_file_name}`);const output_file_path = path.join( __dirname, `../output files/${input_log_file_name}`);console.log(input_file_path);async function processLineByLine() { const fileStream = fs.createReadStream(input_file_path); const rl = readline.createInterface({ input: fileStream, crlfDelay: Infinity, }); // 정규식 const reg404 = /^.*(404).*/; let result_string = ''; for await (const line of rl) { // console.log(`Line from file: ${line}`); if (reg404.test(line)) { // console.log(`hello : ${line}`); result_string += line + '\\r\\n'; } } fs.writeFile(output_file_path, result_string, 'utf8', function (err) { if (err) throw err; console.log('file write complete'); });}processLineByLine(); readline으로 한줄한줄 읽기123456const fileStream = fs.createReadStream(input_file_path);const rl = readline.createInterface({ input: fileStream, crlfDelay: Infinity,}); 우선, 파일을 한줄씩 읽기위해 readline을 사용했다 정규식으로 404 문자열 포함 여부 확인123456789101112// 정규식const reg404 = /^.*(404).*/;let result_string = '';for await (const line of rl) { // console.log(`Line from file: ${line}`); if (reg404.test(line)) { // console.log(`hello : ${line}`); result_string += line + '\\r\\n'; }} ^.*(404).* 로 정규식을 새웠다. ^.* ; 아무 문자로 시작하는 0개 이상의 문자열로 시작하고 (404) ; 404 문자열을 중간에 포함하며 .* ; 아무 문자열로 끝나는가 reg404.test(line)로 한줄한줄 확인하고 참인 경우에 result_string 에 더하기 result_string 결과 새파일로 쓰기1234fs.writeFile(output_file_path, result_string, 'utf8', function (err) { if (err) throw err; console.log('file write complete');}); result_string에는 404 문자열을 포함한느 라인만 추출되었고 output_file_path에 해당 내용을 쓴다.","link":"/2020/11/09/%EC%A0%95%EA%B7%9C%EC%8B%9D-%ED%8A%B9%EC%A0%95-%EB%AC%B8%EC%9E%90%EC%97%B4%EC%9D%84-%ED%8F%AC%ED%95%A8%ED%95%98%EB%8A%94-%EC%A4%84-%EB%9D%BC%EC%9D%B8-%ED%8C%90%EB%8B%A8/"},{"title":"윈도우10에서 선택영역 캡처하기","text":"더이상 print screen key 그림판 ctrl v, crop, ctrl c, ctrl v 할 필요가없다. Win + Shift + S 단축키를 누르면 중앙 상단에 ui가 나오면서 드래그로 원하는 영역을 캡처할 수 있다. 스크린샷은 클립보드에 저장되면 원하는 곳에 붙여넣어 사용할 수 있다. 다른 캡쳐 단축키Alt + PrintScreen 현재 활성화된창을 캡처한다. 이것도 많이 쓴다. PrintScreen 전체화면 캡처","link":"/2020/10/06/%EC%9C%88%EB%8F%84%EC%9A%B010%EC%97%90%EC%84%9C-%EC%84%A0%ED%83%9D%EC%98%81%EC%97%AD-%EC%BA%A1%EC%B2%98%ED%95%98%EA%B8%B0/"},{"title":"자릿수 더하기","text":"자릿수 더하기1234567891011// https://programmers.co.kr/learn/courses/30/lessons/12931function solution(n) { let answer; n = `${n}`; n = n.split(''); answer = n.reduce((prev, curr) =&gt; { return parseInt(curr) + parseInt(prev); }, 0); return answer;}result = solution(123); 해설 각 자릿수를 더해서 반환한다 reduce로 각 자릿수의 합을 구한다.","link":"/2020/09/18/%EC%9E%90%EB%A6%BF%EC%88%98-%EB%8D%94%ED%95%98%EA%B8%B0/"},{"title":"자연수 뒤집어 배열로 만들기","text":"자연수 뒤집어 배열로 만들기12345678// https://programmers.co.kr/learn/courses/30/lessons/12932function solution(n) { var answer = []; answer = `${n}`.split('').map(Number); answer.reverse(); return answer;}result = solution(12345); 해설 입력으로 정수가 들어오면 거꾸로된 배열로 반환한다 입력받은 정수를 문자열로 만든다 split으로 문자 배열로 만든다 map으로 다시 숫자 배열로 만든다 reverse로 뒤집는다.","link":"/2020/09/18/%EC%9E%90%EC%97%B0%EC%88%98-%EB%92%A4%EC%A7%91%EC%96%B4-%EB%B0%B0%EC%97%B4%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"title":"정수 내림차순으로 배치하기","text":"정수 내림차순으로 배치하기123456789// https://programmers.co.kr/learn/courses/30/lessons/12933function solution(n) { n = n + ''; let arr = n.split(''); arr.sort((a, b) =&gt; b - a); arr = arr.join(''); return Number(arr);}result = solution(118372); 해설 정수가 들어오면 내림차순으로 배치해서 = 가장 큰 수를 만들어서 반환하면된다. 정수를 문자열로 캐스팅한다. 문자열에서 문자하나하나의 배열로 변환하고 내림차순 정렬한다. 배열을 문자열로 만든다. 문자열을 숫자로 캐스팅한다.","link":"/2020/09/18/%EC%A0%95%EC%88%98-%EB%82%B4%EB%A6%BC%EC%B0%A8%EC%88%9C%EC%9C%BC%EB%A1%9C-%EB%B0%B0%EC%B9%98%ED%95%98%EA%B8%B0/"},{"title":"정수 제곱근 판별","text":"정수 제곱근 판별12345678910// https://programmers.co.kr/learn/courses/30/lessons/12934function solution(n) { let answer = -1; const x = Math.sqrt(n); if (Number.isInteger(x)) { answer = Math.pow(x + 1, 2); } return answer;}result = solution(121); 해설 입력으로 정수가 들어오면 제곱근 x를 구해서 양의 정수이면 (x+1)^2을 반환한다 양의 정수가 아니면 -1을 반환한다. Math.sqrt(n) 은 제곱근을 구하는 함수다. math.pow() 는 제곱하는 함수다.","link":"/2020/09/18/%EC%A0%95%EC%88%98-%EC%A0%9C%EA%B3%B1%EA%B7%BC-%ED%8C%90%EB%B3%84/"},{"title":"정처기 으악","text":"정보처리기사 책을 펴고 30분 봣는데 모니터 보는 것 보다 눈이 아파서 때려쳤다. 막연한 이론은 공부할 엄두가 안난다…","link":"/2020/11/06/%EC%A0%95%EC%B2%98%EA%B8%B0-%EC%9C%BC%EC%95%85/"},{"title":"정보처리기사 카테고리 생성","text":"정보처리기사 공부한 내용 올리기","link":"/2020/10/16/%EC%A0%95%EC%B2%98%EA%B8%B0/"},{"title":"제일 작은 수 제거하기","text":"제일 작은 수 제거하기1234567891011121314151617// https://programmers.co.kr/learn/courses/30/lessons/12935function solution(arr) { var answer = [-1]; // 하나일때 바로 반환 if (arr.length == 1) { return answer; } let min = Math.min.apply(null, arr); // let min = Math.min(...arr); let tmp = arr.filter((val, idx) =&gt; { return val != min; }); console.log(tmp); return tmp;}result = solution([4, 3, 2, 1]); 해설 입력으로 배열이 들어오면, 그중에서 가장 작은 수를 없애고 리턴하면 된다. 정렬을 사용하면 편하겠지만 원래의 배열 순서에서 최소값만 쏙하고 빼서 리턴해야한다. 나는 배열에서 최소값을 구하고 필터를 통해서 최소값을 제외한 배열을 얻어서 반환했다. 다른 사람의 풀이123456function solution2(arr) { arr.splice(arr.indexOf(Math.min(...arr)), 1); if (arr.length &lt; 1) return [-1]; return arr;}result = solution([4, 3, 2, 1]); 음.. 그러하다.","link":"/2020/09/18/%EC%A0%9C%EC%9D%BC-%EC%9E%91%EC%9D%80-%EC%88%98-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0/"},{"title":"중첩 카테고리, 여러개 태그 쓰는법","text":"123456789101112---title: 중첩 카테고리, 여러개 태그 쓰는법date: 2020-09-16 15:50:18tags: - tmp tag1 - tmp tag2categories: - tmp cat1 - tmp cat2 - tmp cat3---","link":"/2020/09/16/%EC%A4%91%EC%B2%A9-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC-%EC%97%AC%EB%9F%AC%EA%B0%9C-%ED%83%9C%EA%B7%B8-%EC%93%B0%EB%8A%94%EB%B2%95/"},{"title":"직사각형 별찍기","text":"직사각형 별찍기123456789101112// https://programmers.co.kr/learn/courses/30/lessons/12969process.stdin.setEncoding('utf8');process.stdin.on('data', (data) =&gt; { const n = data.split(' '); const a = Number(n[0]), b = Number(n[1]); for (let index = 0; index &lt; b; index++) { const row = '*'.repeat(a); console.log(row); }}); 해설 별찍기!","link":"/2020/09/18/%EC%A7%81%EC%82%AC%EA%B0%81%ED%98%95-%EB%B3%84%EC%B0%8D%EA%B8%B0/"},{"title":"체육복","text":"체육복1234567891011121314151617181920212223242526272829303132333435363738394041// https://programmers.co.kr/learn/courses/30/lessons/42862function solution(n, lost, reserve) { var answer = 0; let arr = []; for (let i = 0; i &lt; n; i++) { arr[i] = 1; } for (let i = 0; i &lt; reserve.length; i++) { arr[reserve[i] - 1]++; } for (let i = 0; i &lt; lost.length; i++) { arr[lost[i] - 1]--; } for (let i = 0; i &lt; arr.length; i++) { // 앞에사람꺼 빌리기 if (arr[i] == 0) { if (arr[i - 1] == 2) { arr[i - 1]--; arr[i]++; continue; } // 뒤에사람꺼 빌리기 else if (arr[i + 1] == 2) { arr[i + 1]--; arr[i]++; continue; } } } const result = arr.filter((value, index) =&gt; { return value != 0; }); return result.length;}solution(5, [2, 4], [1, 3, 5]); 해설 체육복을 입을 수 있는 사람의 수를 구하는 문제다. 체육복을 빌릴 수 있는데, 앞 뒤 사람의 체육복만 빌릴 수 있다. 먼저 arr 배열을 초기화한다. lost는 -1, reserve는 +1 앞에서부터 순차적으로 앞사람확인하고 여벌이 있으면 빌린다 앞사람없으면 뒤에서 빌린다.","link":"/2020/09/18/%EC%B2%B4%EC%9C%A1%EB%B3%B5/"},{"title":"커스텀 404 페이지 만들기","text":"루트 디렉터리에 404.html이 존재하면 기존 404 페이지를 대신해 보여준다. hexo에서 적용시키려면 source 디렉터리에 404.html을 만들면된다. 그런데 hexo에서 배포할때 자동으로 테마에 맞게 지정된 레이아웃으로 변환한다. 이를 막기 위해 404.html의 Front-matter 에 layout: false로 지정한다 source/404.html12345---layout: false---&lt;!DOCTYPE html&gt; Front-matter hexo에서 파일 최상단에 적는 yml을 Front-matter라고 한다. Front-matter123456789101112---title: 커스텀 404 페이지 만들기toc: truecategory: blogtags: - hexo - 404 - custom pagethumbnail: /images/커스텀-404-페이지-만들기20200921/preview.jpgdate: 2020-09-21 09:15:59--- 404 소스 출처 https://codepen.io/purplexmoss/pen/PoPyzMW","link":"/2020/09/21/%EC%BB%A4%EC%8A%A4%ED%85%80-404-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"title":"코드 스니펫 안에 &#96;&#96;&#96; 포함하기","text":"tmp.md12345오호호```js tmp.jsconsole.log(1);``` 이렇게 스니펫으로 ``` 을 표현할 수 있다. 하는 법하는법1234567````md tmp.md오호호```js tmp.jsconsole.log(1);``````` 바깐 스니펫의 ` 개수를 4개 안쪽 스니펫의 ` 개수를 3개로 하면 된다.","link":"/2020/09/23/%EC%BD%94%EB%93%9C-%EC%8A%A4%EB%8B%88%ED%8E%AB-%EC%95%88%EC%97%90-%EC%BD%94%EB%93%9C-%EC%8A%A4%EB%8B%88%ED%8E%AB-%ED%8F%AC%ED%95%A8%ED%95%98%EA%B8%B0/"},{"title":"최대공약수와 최소공배수","text":"최대공약수와 최소공배수123456789101112// https://programmers.co.kr/learn/courses/30/lessons/12940function solution(n, m) { var answer = []; function gcd(a, b) { return b ? gcd(b, a % b) : a; } let tmp = gcd(n, m); answer.push(tmp); answer.push((n * m) / tmp); return answer;}result = solution(3, 12); 해설 GCD ; greatest common divisor ; 최대공약수 입력으로 두 수가 들어오면 [ 최대공약수, 최소공배수 ]를 반환한다 최대공약수는 gcd함수를 이용해서 재귀적으로 구하고 최소공배수는 n * m / gcd 로 구할 수 있다.","link":"/2020/09/18/%EC%B5%9C%EB%8C%80%EA%B3%B5%EC%95%BD%EC%88%98%EC%99%80-%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98/"},{"title":"[카카오 인턴] 키패드 누르기","text":"[카카오 인턴] 키패드 누르기12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// https://programmers.co.kr/learn/courses/30/lessons/67256function solution(numbers, hand) { // 1,4,7 ; left // 2,5,8,0 ; 가까운거, 같을시 왼손잡이냐 오른손잡이냐 // 3,6,9 ; right switch (hand) { case 'left': hand = 'L'; break; default: hand = 'R'; break; } let curleft = '*'; let curright = '#'; let answer = ''; const maptable = { 1: { low: 0, col: 0 }, 2: { low: 0, col: 1 }, 3: { low: 0, col: 2 }, 4: { low: 1, col: 0 }, 5: { low: 1, col: 1 }, 6: { low: 1, col: 2 }, 7: { low: 2, col: 0 }, 8: { low: 2, col: 1 }, 9: { low: 2, col: 2 }, '*': { low: 3, col: 0 }, 0: { low: 3, col: 1 }, '#': { low: 3, col: 2 }, }; let keypad = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], [-1, 0, -2], ]; function getCost(num, cur) { let cost = 0; const src = maptable[cur]; const des = maptable[num]; let low = Math.abs(des['low'] - src['low']); let col = Math.abs(des['col'] - src['col']); cost = low + col; return cost; } let x; numbers.forEach((number, idx) =&gt; { if (number.toString().match(/[369]/)) { x = 'R'; curright = number; } else if (number.toString().match(/[147]/)) { x = 'L'; curleft = number; } else { // 가까운손 const costleft = getCost(number, curleft); const costright = getCost(number, curright); if (costleft == costright) { x = hand; switch (hand) { case 'L': curleft = number; break; default: curright = number; break; } } else if (costleft &gt; costright) { x = 'R'; curright = number; } else { x = 'L'; curleft = number; } } answer += x; }); return answer;}result = solution([1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5], 'right');result = solution([7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2], 'left');result = solution([1, 2, 3, 4, 5, 6, 7, 8, 9, 0], 'right'); 해설 입력으로 키패드를 누르는 순서와 왼손잡이인지 오른손잡이인지 알려주는 문자열을 받는다 그러면 “LRLLLRLLRRL” 식으로 각 숫자를 어떤 손으로 눌렀는지 문자열로 반환한다 147, 369는 좌우 키패드이기때문에 어떤 손으로 눌러야하는 정해져 있고, 문제는 가운데 있는 키들이다. 2580 2580중 하나의 키를 눌러야하는 상황이면 가까운 손으로 눌러야한다 거리가 같은 경우에는 왼손잡이는 왼손으로, 오른손잡이는 오른손으로 누른다. 나는 정규식으로 147, 369를 처리하고 가운데 키를 누르는 경우에는 왼손 오른손 누가더 가까운데 getCost 함수로 비교한다. getCost함수는 그냥 몇칸 떨어져 있는지 비교하는 단순한 함수이다. maptable이라는걸 만들어서 키패드를 2차원 배열로 표시해을 때 인덱스를 저장했다.","link":"/2020/09/18/%EC%B9%B4%EC%B9%B4%EC%98%A4-%EC%9D%B8%ED%84%B4-%ED%82%A4%ED%8C%A8%EB%93%9C-%EB%88%84%EB%A5%B4%EA%B8%B0/"},{"title":"카카오 이미지 검색 api 사용하기","text":"카카오 이미지 검색 API를 사용해보자 따라하기 이미지가 먼저오고 그 아래에 설명이 있습니다! 준비물 postman kakao developers 가입하기 카카오 api 사용이 처음이라면 kakao developers에 가입해야한다. 이미 있는 카카오 계정으로 가입할 수 있다. REST API 키 발급받기 내 애플리케이션 &gt; 애플리케이션 추가하기 를 눌러준다. 앱 이름, 사업자명을 입력하고 저장을 눌러준다. 방금 만든 앱을 클릭하여 앱 키 &gt; rest api 키를 확인한다. POSTMAN으로 확인하기 포스트맨을 켜주시고, 아래 텍스트를 복사해 붙여넣어준다. url1https://dapi.kakao.com/v2/search/image?query=안녕 Headers 탭에 들어가서 2-1. Authorizationkey를 하나 추가하고 2-2. value로는 KakaoAK {방금 발급받은 rest api key}를 넣어준다. KakaoAK 와 키 사이에 하나의 공백이 있음을 유의한다. Send 버튼을 눌러 결과를 확인한다. 검색 옵션 사용하기 위에서는 필수 파라미터인 query만 사용해 검색을 해보았다. 포스트맨 Params 탭으로가서 이것저것 테스트해보길.. https://developers.kakao.com/docs/latest/ko/daum-search/dev-guide#search-image Name Type Description Required query String 검색을 원하는 질의어 O sort String 결과 문서 정렬 방식, accuracy(정확도순) 또는 recency(최신순), 기본 값 accuracy X page Integer 결과 페이지 번호, 1~50 사이의 값, 기본 값 1 X size Integer 한 페이지에 보여질 문서 수, 1~80 사이의 값, 기본 값 80 X 참고 카카오 이미지 검색 api를 활용한 ios앱","link":"/2020/09/24/%EC%B9%B4%EC%B9%B4%EC%98%A4-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EA%B2%80%EC%83%89-api-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"title":"vscode 터미널 토글 단축키","text":"vscode 내장 터미널영역을 토글할 수 있다. Ctrl + J vscode 내장 터미널 토글 Ctrl + Shift + C cmd 열기","link":"/2020/10/06/%ED%84%B0%EB%AF%B8%EB%84%90-%ED%86%A0%EA%B8%80-%EB%8B%A8%EC%B6%95%ED%82%A4/"},{"title":"리액트로 네이버 퍼센트 계산기 클론코딩","text":"막 배운 리액트로 처음 만들어본 프로젝트이다 계산하기 귀찮아하는 나는 평소 네이버 퍼센트 계산기를 이용했었는데 이 계산기를 리액트를 사용해 클론코딩해보자.. 데모 Percentage Calculator (React) 후기 내가 너무 간단한 것을 만들어서 그런지 모르겠지만 리액트를 처음 써본 내 기준으로 너무 복잡하다고 느껴졌다. 기존에 html, css, js로 만들때 보다 시간이 배로 걸렸다. 나중에 훨씬 복잡한 것을 만들게 되었을 때 리액트가 좋다고한다. 이미 잘 만들어진 리액트 튜토리얼을 따라만들고, 수정하는 방식으로 만들었다. 사용한 개념에 대해 완전히 이해하고 익숙해지는데 시간이 필요할 것 같다. 소스코드 react-percentage-calculator readme.md에 리액트로 만든 화면을 깃허브 페이지로 보여주는 방법 등 메모해놨다.","link":"/2020/09/22/%ED%8D%BC%EC%84%BC%ED%8A%B8-%EA%B3%84%EC%82%B0%EA%B8%B0/"},{"title":"프로그래머스 문제풀이 카테고리 생성","text":"javascript 공부하면서 프로그래머스 풀었던 것 올리는 곳!","link":"/2020/09/18/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC-%EC%83%9D%EC%84%B1/"},{"title":"콜라츠 추측","text":"콜라츠 추측123456789101112131415161718192021// https://programmers.co.kr/learn/courses/30/lessons/12943function solution(num) { let answer = 0; let curval = num; let i; for (i = 0; i &lt; 500; i++) { console.log(i, curval); if (curval == 1) { break; } if (curval % 2 == 0) { curval /= 2; } else { curval *= 3; curval++; } } answer = i == 500 ? -1 : i; return answer;}result = solution(6); 해설 1-1. 입력된 수가 짝수라면 2로 나눕니다.1-2. 입력된 수가 홀수라면 3을 곱하고 1을 더합니다.2. 결과로 나온 수에 같은 작업을 1이 될 때까지 반복합니다. 위 과정을 반복하면 모든 수를 1로 만들 수 있다는게 콜라츠 추측.. 위 과정을 코드로 표현한다.","link":"/2020/09/18/%EC%BD%9C%EB%9D%BC%EC%B8%A0-%EC%B6%94%EC%B8%A1/"},{"title":"특정 브랜치 클론하기","text":"123git clone -b {브랜치명} --single-branch {저장소}git clone -b docker --single-branch https://github.com/chinsun9/2020-web-test.git 저장소에 여러 브랜치가 있는데, 특정 하나의 브랜치만 클론하고 싶을때! git clone -b docker –single-branch https://github.com/chinsun9/2020-web-test.git https://github.com/chinsun9/2020-web-test.git 저장소의 docker라는 브랜치를 클론하는 명령이다.","link":"/2020/10/21/%ED%8A%B9%EC%A0%95-%EB%B8%8C%EB%9E%9C%EC%B9%98-%ED%81%B4%EB%A1%A0%ED%95%98%EA%B8%B0/"},{"title":"포트 포워딩 체크 웹 클론코딩","text":"서버를 열어놨는데, 외부에서 접근이 가능한지 불가능한지, 포트포워딩을 확인하고 싶으면 핸드폰을 열고 데이터를 켜서 내 서버로 접속해서 확인하는 등 번거롭게 확인했다. https://www.yougetsignal.com/tools/open-ports/ 라는 포트포워딩 체크 웹이 있는데 이거를 한번 클론 코딩해보았다. 영상설명 나는 ec2에 올려서 테스트해봤다 주소창에 보면 15.165.000.000:4000 으로 나오는데 내 ec2 ip인데 일부러 뒷부분을 000.000으로 바꿔놨다. 이 앱은 ec2의 4000포트에서 동작중이다. 도메인명이나 ip를 입력하고 포트입력란에 원하는 포트를 입력한다. 그리고 check 버튼을 누르면 해당 포트가 열려있는지 확인한다. 당연히 해당 포트를 리슨하는 서버가 동작하고 있어야한다. 우측 common ports 에서 원하는 포트를 클릭하면 해당 포트로 요청을 보낸다. Scan All Common Ports 버튼을 눌러 모든 common port를 스캔한다. 0:18 중간에는 마인크래프트 서버를 체크해본다. 0:35 localhost로 적으면 내 ec2의 포트를 스캔하게된다. localhost를 common port를 모두 스캔해보니 3000번이 열려있다는 것을 알 수 있다 0:48 이 앱이 실행되고 있는 4000번 포트를 스캔해보니 당연하게 열려있는 모습을 확인할 수 있다 소스코드 open-port-check-web","link":"/2020/11/03/%ED%8F%AC%ED%8A%B8-%ED%8F%AC%EC%9B%8C%EB%94%A9-%EC%B2%B4%ED%81%AC-%EC%9B%B9-%ED%81%B4%EB%A1%A0%EC%BD%94%EB%94%A9/"},{"title":"하샤드 수","text":"하샤드 수12345678910111213141516// https://programmers.co.kr/learn/courses/30/lessons/12947function solution(x) { let answer = true; const saveX = x; x += ''; arr = x.split(''); arr = arr.map(Number); const result = arr.reduce((prev, curr) =&gt; { return curr + prev; }, 0); if (saveX % result != 0) { answer = false; } return answer;}result = solution(10); 해설 정수 입력이 들어오면 하샤드 수인지 판별하여 bool을 반환 정수를 자릿수별로 조작하기 위해 문자열로 캐스팅 문자열을 배열로 변환 배열의 각 원소는 문자인데 map으로 숫자로 캐스팅 reduece로 자릿수의 합을 구합 나누어 떨어지는 확인 하샤드 수123456789181 + 8 = 918 % 9 == 018은 하샤드 수!191 + 9 = 1019 * 10 != 019는 아님! 자릿수를 모두 더한다.(10진수 기준) 자릿수를 모두 더한 합으로 원래 수를 나눴을 때 나누어 떨어지는지 판별한다.","link":"/2020/09/18/%ED%95%98%EC%83%A4%EB%93%9C-%EC%88%98/"},{"title":"핸드폰 번호 가리기","text":"핸드폰 번호 가리기12345678910// https://programmers.co.kr/learn/courses/30/lessons/12948function solution(phone_number) { let answer = ''; for (let index = 0; index &lt; phone_number.length - 4; index++) { answer += '*'; } return answer + phone_number.slice(-4);}result = solution('01033334444'); 해설 인풋 문자열에서 뒤 4자리만 남기고 '*'문자로 변환하는 거다. 나는 그냥 인풋 문자열 길이에서 4번 적게 '*'을 찍고 마지막 문자열 4개를 잘라다가 붙였다. 다른 사람의 풀이1234// 정규식 풀이 다른사람function hide_numbers(s) { return s.replace(/\\d(?=\\d{4})/g, '*');} 정규식을 이용해 아름답게 줄였다.. 참고 정규식 시각화하는 곳 https://regexr.com/ https://regexper.com/","link":"/2020/09/18/%ED%95%B8%EB%93%9C%ED%8F%B0-%EB%B2%88%ED%98%B8-%EA%B0%80%EB%A6%AC%EA%B8%B0/"},{"title":"행렬의 덧셈","text":"1234567891011121314151617181920212223// https://programmers.co.kr/learn/courses/30/lessons/12950function solution(arr1, arr2) { var answer = []; arr1.forEach((row, rowidx) =&gt; { let tmpRow = []; row.forEach((col, colidx) =&gt; { tmpRow[colidx] = col + arr2[rowidx][colidx]; }); answer.push(tmpRow); }); return answer;}result = solution( [ [1, 2], [2, 3], ], [ [3, 4], [5, 6], ]); 해설 array api forEach 쓸때 index 값을 두번째 파라미터로 받을 수 있다. 그래서 구조가 같은 배열(행렬)의 경우 반복문 하나로 돌릴 수 있다. 다른 사람의 풀이1234// 다른사람 풀이 mapfunction sumMatrix(A, B) { return A.map((a, i) =&gt; a.map((x, j) =&gt; x + B[i][j]));} map을 이용해서 간결하게 표현했다..","link":"/2020/09/18/%ED%96%89%EB%A0%AC%EC%9D%98-%EB%8D%A7%EC%85%88/"},{"title":"현재 디렉터리에서 cmd열기","text":"꿀꿀 탐색기 주소에 cmd 탐색기를 돌아다니다가 해당 디렉터리에서 터미널을 열고 싶을 때 탐색기 주소창에다 cmd 반대의 경우 터미널에서 작업하다가 해당 디렉터리를 탐색기에서 보고 싶을 때 explorer . cmd와 다르게 .을 써줘야한다. cmd1explorer .","link":"/2020/10/07/%ED%98%84%EC%9E%AC-%EB%94%94%EB%A0%89%ED%84%B0%EB%A6%AC%EC%97%90%EC%84%9C-cmd%EC%97%B4%EA%B8%B0/"},{"title":"AWS 네트워크 ACL","text":"VPC를 위한 선택적 보안 계층 시큐리티 그룹과 다르게 차단, deny 룰을 사용할 수 있다. ruleNumber가 낮은 숫자일수록 우선적용된다. 20개까지 규칙을 지정할 수 있다고 한다. 실제로 가용가능한 개수는 18개다. 1234567891011121314{ CidrBlock: '0.0.0.0/0', Egress: false, Protocol: '-1', RuleAction: 'allow', RuleNumber: 100},{ CidrBlock: '0.0.0.0/0', Egress: false, Protocol: '-1', RuleAction: 'deny', RuleNumber: 32767} 인바운드의 경우 이 2개가 기본적으로 세팅되어있다. aws-sdk 로 ACL 룰 추가, 교체하기acl.ts1234567891011121314151617181920212223242526272829var in_params: EC2.CreateNetworkAclEntryRequest = { CidrBlock: ipv4 + '/24', Egress: false, //If true, OUTbound rule. fasle is INbound NetworkAclId: aclId, Protocol: `6`, // -1 : all protocl // 6 : 사용자 지정 tcp PortRange: { From: 80, To: 443 }, // http - https RuleAction: 'deny', RuleNumber: acl_cnt, // 우선순위 ruleNumber};// 기존 존재하는 acl 규칙 개수에 따라서 mode를 달리한다// mode값에 따라 메소드를 달리함.// 20개가 안되는 경우 createNetworkAclEntry 를 사용함// 20개 모두 찬경우 replaceNetworkAclEntry를 통해 교체하는 방법const method = mode === 'create' ? 'createNetworkAclEntry' : 'replaceNetworkAclEntry';return new Promise((resolve, reject) =&gt; { ec2[method](in_params, function (err, data) { if (err) { console.log(err.message, acl_cnt); return reject(err.message); } else { console.log('Create AclEntry Successful : \\n', in_params); // successful response resolve(in_params); } });}); 이상한 요청을 차단하기 위해 알아보았다 참고 네트워크 ACL AWS VPC를 디자인해보자(2) - ACL과 Security Group을 활용한 보안 강화 Amazon VPC 할당량","link":"/2020/11/11/AWS/"},{"title":"insert, update시 자동갱신 TIMESTAMP","text":"123456789CREATE TABLE LOG( `idx` INT NOT NULL AUTO_INCREMENT, `ip` VARCHAR(45) NOT NULL, `method` VARCHAR(45) NOT NULL, `url` VARCHAR(45) NOT NULL, `date` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (idx)); CURRENT_TIMESTAMP은 현재 시간을 의미한다. DEFAULT CURRENT_TIMESTAMP ; insert 시 자동으로 현재 시간이 들어간다 ON UPDATE CURRENT_TIMESTAMP ; update 시 자동으로 현재 시간으로 갱신된다.","link":"/2020/11/11/insert/"},{"title":"react typescript Prettier 적용하기, Prettier로 여러 파일 한번에 포맷팅하기","text":"settings.json1234567&quot;[typescript]&quot;: { &quot;editor.formatOnSave&quot;: true, &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;},&quot;[typescriptreact]&quot;: { &quot;editor.formatOnSave&quot;: true, &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; settings.json에 추가시켜준다. 저장할 때마다 자동으로 포맷팅되는 것을 확인할 수 있다. 일괄적으로 포맷팅하기 프리티어없이 개발했다가 코드 포맷팅을 일괄적으로 하고싶을 때가 있다. .prettierrc1234567{ &quot;singleQuote&quot;: true, &quot;parser&quot;: &quot;typescript&quot;, &quot;semi&quot;: true, &quot;printWidth&quot;: 120, &quot;tabWidth&quot;: 2} .prettierrc 파일을 생성한다. npx prettier –write */.{tsx,ts} terminal에 위 명령을 치면 prettier가 일회성으로 설치되면서 지정한 확장자에 대해 포맷팅을 일괄적으로 실행해준다. .prettierrc prettier config file을 참고해서 실행되니 원하는 디렉터리만, 또는 무시할 디렉터리, 파일들을 설정해서 사용할 수 있다. 참고 Prettier Configuration File","link":"/2020/11/12/react-typescript-Prettier-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"title":"nodejs web dockerizing","text":"기존에 만들었었던 Nodejs Express WEB 프로젝트를 도커라이징 해보았다. 얄팍한 코딩사전님의 가장 쉽게 배우는 도커를 보고 시도했다. 도커가 이런거구나 하고 느낀 순간이였다.. 마치 신세계… 이번 도커라이징을 통해서 내 프로젝트를 도커가 설치되어있는 다른컴퓨터에서 매우 쉽게 돌려볼 수 있다는걸 알게되었다. 기존 상태 설명디렉터리 구조12345678910111213141516.├── node_modules/├── web│ ├── bin│ │ └── www│ ├── public/│ ├── routes/│ ├── utils/│ ├── views/│ └── app.js├── .gitattributes├── .gitignore├── package-lock.json├── package.json├── README.md└── sqldump.sql 그냥 node express 서버와 db덤프 파일인 sqldump.sql 가 구분없이 한 디렉터리에 있었다. 벡엔드와 데이터베이스로 분리하기 backend, database 폴더를 만든다. backend폴더로 sqldump.sql와 깃허브, 프리티어 세팅 등을 제외한 99.9999%의 소스파일들을 이동한다 database폴더로 sqldump.sql을 이동 sqldump.sql 이동123database└── scripts └── sqldump.sql 이런식으로 node express 서버와 db를 분리할 수 있었다. Dockerfile 작성하기backendbackend/Dockerfile12345678FROM node:12.18.3WORKDIR /usr/src/appCOPY . .RUN npm iCMD [&quot;npm&quot;, &quot;start&quot;] 내가 로컬에서 사용하는 환경을 토대로 내 앱에 맞는 노드버전을 가져와서 /usr/src/app 라는 워크디렉터리에 backend 아래있는 모든 파일들을 복사해오고 RUN 명령어로 npm i로 종속성을 설치한다. 그리고 CMD 명령으로 backend 서버를 실행시킨다. databasedatabase/Dockerfile12345678FROM mariadb:10.5ENV MYSQL_USER mysql_userENV MYSQL_PASSWORD 1234ENV MYSQL_ROOT_PASSWORD 1234ENV MYSQL_DATABASE webtestCOPY ./scripts/ /docker-entrypoint-initdb.d/ 내가 로컬에서 사용했던 마리아디비 버전 그대로 가져왔다 데이터베이스 관련 환경변수들을 정의해주고 scripts 디렉터리에 있는 dump파일을 /docker-entrypoint-initdb.d/ 로 복사한다 /docker-entrypoint-initdb.d/ 는 데이터베이스를 생성할 때, 하위 sql을 가지고 데이터베이스를 초기화해준다. 후기 메모리 딸린다.. 처음에는 좋아서 이것저것 다 도커라이징할려고 했는데, 하다보니까 메모리가 딸려서 마우스가 뚝뚝 끊겼다… 참고 Nodejs Express WEB 가장 쉽게 배우는 도커","link":"/2020/11/12/nodejs/"}],"tags":[{"name":"aws","slug":"aws","link":"/tags/aws/"},{"name":"acl","slug":"acl","link":"/tags/acl/"},{"name":"network","slug":"network","link":"/tags/network/"},{"name":"vpc","slug":"vpc","link":"/tags/vpc/"},{"name":"sg","slug":"sg","link":"/tags/sg/"},{"name":"security groups","slug":"security-groups","link":"/tags/security-groups/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"chrome","slug":"chrome","link":"/tags/chrome/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"dockerizing","slug":"dockerizing","link":"/tags/dockerizing/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"express","slug":"express","link":"/tags/express/"},{"name":"mariadb","slug":"mariadb","link":"/tags/mariadb/"},{"name":"gitignore","slug":"gitignore","link":"/tags/gitignore/"},{"name":"elb","slug":"elb","link":"/tags/elb/"},{"name":"morgan","slug":"morgan","link":"/tags/morgan/"},{"name":"ts","slug":"ts","link":"/tags/ts/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"hook","slug":"hook","link":"/tags/hook/"},{"name":"clone coding","slug":"clone-coding","link":"/tags/clone-coding/"},{"name":"클론코딩","slug":"클론코딩","link":"/tags/%ED%81%B4%EB%A1%A0%EC%BD%94%EB%94%A9/"},{"name":"programmers","slug":"programmers","link":"/tags/programmers/"},{"name":"프로그래머스","slug":"프로그래머스","link":"/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"sql","slug":"sql","link":"/tags/sql/"},{"name":"rds","slug":"rds","link":"/tags/rds/"},{"name":"db","slug":"db","link":"/tags/db/"},{"name":"grant","slug":"grant","link":"/tags/grant/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"sysout","slug":"sysout","link":"/tags/sysout/"},{"name":"비동기","slug":"비동기","link":"/tags/%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"name":"async","slug":"async","link":"/tags/async/"},{"name":"await","slug":"await","link":"/tags/await/"},{"name":"resolve","slug":"resolve","link":"/tags/resolve/"},{"name":"reject","slug":"reject","link":"/tags/reject/"},{"name":"typedoc","slug":"typedoc","link":"/tags/typedoc/"},{"name":"tsdoc","slug":"tsdoc","link":"/tags/tsdoc/"},{"name":"a tag","slug":"a-tag","link":"/tags/a-tag/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"ec2","slug":"ec2","link":"/tags/ec2/"},{"name":"security group","slug":"security-group","link":"/tags/security-group/"},{"name":"keypair","slug":"keypair","link":"/tags/keypair/"},{"name":"remote","slug":"remote","link":"/tags/remote/"},{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"pem","slug":"pem","link":"/tags/pem/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"category","slug":"category","link":"/tags/category/"},{"name":"cmd","slug":"cmd","link":"/tags/cmd/"},{"name":"taskkill","slug":"taskkill","link":"/tags/taskkill/"},{"name":"process","slug":"process","link":"/tags/process/"},{"name":"bat","slug":"bat","link":"/tags/bat/"},{"name":"batch file","slug":"batch-file","link":"/tags/batch-file/"},{"name":"관리자 권한 실행","slug":"관리자-권한-실행","link":"/tags/%EA%B4%80%EB%A6%AC%EC%9E%90-%EA%B6%8C%ED%95%9C-%EC%8B%A4%ED%96%89/"},{"name":"관리자 권한","slug":"관리자-권한","link":"/tags/%EA%B4%80%EB%A6%AC%EC%9E%90-%EA%B6%8C%ED%95%9C/"},{"name":"rmdir","slug":"rmdir","link":"/tags/rmdir/"},{"name":"crlf","slug":"crlf","link":"/tags/crlf/"},{"name":"lf","slug":"lf","link":"/tags/lf/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"mysql2","slug":"mysql2","link":"/tags/mysql2/"},{"name":"connection","slug":"connection","link":"/tags/connection/"},{"name":"connection pool","slug":"connection-pool","link":"/tags/connection-pool/"},{"name":"mkdir","slug":"mkdir","link":"/tags/mkdir/"},{"name":"disqus","slug":"disqus","link":"/tags/disqus/"},{"name":"copy con","slug":"copy-con","link":"/tags/copy-con/"},{"name":"new file","slug":"new-file","link":"/tags/new-file/"},{"name":"https","slug":"https","link":"/tags/https/"},{"name":"ssl","slug":"ssl","link":"/tags/ssl/"},{"name":"freenom","slug":"freenom","link":"/tags/freenom/"},{"name":"cloudflare","slug":"cloudflare","link":"/tags/cloudflare/"},{"name":"geolocation","slug":"geolocation","link":"/tags/geolocation/"},{"name":"important","slug":"important","link":"/tags/important/"},{"name":"docker hub","slug":"docker-hub","link":"/tags/docker-hub/"},{"name":"push","slug":"push","link":"/tags/push/"},{"name":"fetch","slug":"fetch","link":"/tags/fetch/"},{"name":"ajax","slug":"ajax","link":"/tags/ajax/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"github api","slug":"github-api","link":"/tags/github-api/"},{"name":"commits","slug":"commits","link":"/tags/commits/"},{"name":"commit","slug":"commit","link":"/tags/commit/"},{"name":"readme.md","slug":"readme-md","link":"/tags/readme-md/"},{"name":"gradle","slug":"gradle","link":"/tags/gradle/"},{"name":"build.gradle","slug":"build-gradle","link":"/tags/build-gradle/"},{"name":"lib","slug":"lib","link":"/tags/lib/"},{"name":"db.json","slug":"db-json","link":"/tags/db-json/"},{"name":"md","slug":"md","link":"/tags/md/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"draft","slug":"draft","link":"/tags/draft/"},{"name":"layout","slug":"layout","link":"/tags/layout/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"style","slug":"style","link":"/tags/style/"},{"name":"inline styles","slug":"inline-styles","link":"/tags/inline-styles/"},{"name":"gist","slug":"gist","link":"/tags/gist/"},{"name":"code snippet","slug":"code-snippet","link":"/tags/code-snippet/"},{"name":"tag pulgin","slug":"tag-pulgin","link":"/tags/tag-pulgin/"},{"name":"youtube","slug":"youtube","link":"/tags/youtube/"},{"name":"youtube playlist","slug":"youtube-playlist","link":"/tags/youtube-playlist/"},{"name":"javadoc","slug":"javadoc","link":"/tags/javadoc/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"nohup","slug":"nohup","link":"/tags/nohup/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"li tag","slug":"li-tag","link":"/tags/li-tag/"},{"name":"nofollow","slug":"nofollow","link":"/tags/nofollow/"},{"name":"fs","slug":"fs","link":"/tags/fs/"},{"name":"nodemon","slug":"nodemon","link":"/tags/nodemon/"},{"name":"watch","slug":"watch","link":"/tags/watch/"},{"name":"playlist","slug":"playlist","link":"/tags/playlist/"},{"name":"music","slug":"music","link":"/tags/music/"},{"name":"sqldump","slug":"sqldump","link":"/tags/sqldump/"},{"name":"비용","slug":"비용","link":"/tags/%EB%B9%84%EC%9A%A9/"},{"name":"socketio","slug":"socketio","link":"/tags/socketio/"},{"name":"cli","slug":"cli","link":"/tags/cli/"},{"name":"swift","slug":"swift","link":"/tags/swift/"},{"name":"ImageFinder","slug":"ImageFinder","link":"/tags/ImageFinder/"},{"name":"sam","slug":"sam","link":"/tags/sam/"},{"name":"api gateway","slug":"api-gateway","link":"/tags/api-gateway/"},{"name":"lambda","slug":"lambda","link":"/tags/lambda/"},{"name":"placehold","slug":"placehold","link":"/tags/placehold/"},{"name":"sample image","slug":"sample-image","link":"/tags/sample-image/"},{"name":"layer","slug":"layer","link":"/tags/layer/"},{"name":"rest api","slug":"rest-api","link":"/tags/rest-api/"},{"name":"template.yaml","slug":"template-yaml","link":"/tags/template-yaml/"},{"name":"shell script","slug":"shell-script","link":"/tags/shell-script/"},{"name":"bash","slug":"bash","link":"/tags/bash/"},{"name":"dirpath","slug":"dirpath","link":"/tags/dirpath/"},{"name":"ts-node","slug":"ts-node","link":"/tags/ts-node/"},{"name":"vim","slug":"vim","link":"/tags/vim/"},{"name":"files.exclude","slug":"files-exclude","link":"/tags/files-exclude/"},{"name":"search.exclude","slug":"search-exclude","link":"/tags/search-exclude/"},{"name":"단축키","slug":"단축키","link":"/tags/%EB%8B%A8%EC%B6%95%ED%82%A4/"},{"name":"터미널","slug":"터미널","link":"/tags/%ED%84%B0%EB%AF%B8%EB%84%90/"},{"name":"json","slug":"json","link":"/tags/json/"},{"name":"import","slug":"import","link":"/tags/import/"},{"name":"es6","slug":"es6","link":"/tags/es6/"},{"name":"markdown open preview","slug":"markdown-open-preview","link":"/tags/markdown-open-preview/"},{"name":"ubuntu ami","slug":"ubuntu-ami","link":"/tags/ubuntu-ami/"},{"name":"관리자권한","slug":"관리자권한","link":"/tags/%EA%B4%80%EB%A6%AC%EC%9E%90%EA%B6%8C%ED%95%9C/"},{"name":"workspace","slug":"workspace","link":"/tags/workspace/"},{"name":"setting","slug":"setting","link":"/tags/setting/"},{"name":".vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"limit","slug":"limit","link":"/tags/limit/"},{"name":"pagination","slug":"pagination","link":"/tags/pagination/"},{"name":"install","slug":"install","link":"/tags/install/"},{"name":"thumbnail","slug":"thumbnail","link":"/tags/thumbnail/"},{"name":"readme","slug":"readme","link":"/tags/readme/"},{"name":"github readme stats","slug":"github-readme-stats","link":"/tags/github-readme-stats/"},{"name":"special repository","slug":"special-repository","link":"/tags/special-repository/"},{"name":"github profile","slug":"github-profile","link":"/tags/github-profile/"},{"name":"profile","slug":"profile","link":"/tags/profile/"},{"name":"seo","slug":"seo","link":"/tags/seo/"},{"name":"search engine optimization","slug":"search-engine-optimization","link":"/tags/search-engine-optimization/"},{"name":"google search console","slug":"google-search-console","link":"/tags/google-search-console/"},{"name":"생각","slug":"생각","link":"/tags/%EC%83%9D%EA%B0%81/"},{"name":"도로명 주소","slug":"도로명-주소","link":"/tags/%EB%8F%84%EB%A1%9C%EB%AA%85-%EC%A3%BC%EC%86%8C/"},{"name":"open api","slug":"open-api","link":"/tags/open-api/"},{"name":"api","slug":"api","link":"/tags/api/"},{"name":"local start api","slug":"local-start-api","link":"/tags/local-start-api/"},{"name":"reset","slug":"reset","link":"/tags/reset/"},{"name":"github pages","slug":"github-pages","link":"/tags/github-pages/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"og image","slug":"og-image","link":"/tags/og-image/"},{"name":"etc","slug":"etc","link":"/tags/etc/"},{"name":"img","slug":"img","link":"/tags/img/"},{"name":"symbolic link","slug":"symbolic-link","link":"/tags/symbolic-link/"},{"name":"mklink","slug":"mklink","link":"/tags/mklink/"},{"name":"win v","slug":"win-v","link":"/tags/win-v/"},{"name":"explorer","slug":"explorer","link":"/tags/explorer/"},{"name":"electron","slug":"electron","link":"/tags/electron/"},{"name":"iohook","slug":"iohook","link":"/tags/iohook/"},{"name":"input overlay","slug":"input-overlay","link":"/tags/input-overlay/"},{"name":"reg exp","slug":"reg-exp","link":"/tags/reg-exp/"},{"name":"reg","slug":"reg","link":"/tags/reg/"},{"name":"스샷","slug":"스샷","link":"/tags/%EC%8A%A4%EC%83%B7/"},{"name":"스크린샷","slug":"스크린샷","link":"/tags/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7/"},{"name":"정보처리기사","slug":"정보처리기사","link":"/tags/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"},{"name":"tags","slug":"tags","link":"/tags/tags/"},{"name":"categories","slug":"categories","link":"/tags/categories/"},{"name":"404","slug":"404","link":"/tags/404/"},{"name":"custom page","slug":"custom-page","link":"/tags/custom-page/"},{"name":"정규식","slug":"정규식","link":"/tags/%EC%A0%95%EA%B7%9C%EC%8B%9D/"},{"name":"regexp","slug":"regexp","link":"/tags/regexp/"},{"name":"regular expression","slug":"regular-expression","link":"/tags/regular-expression/"},{"name":"kakao api","slug":"kakao-api","link":"/tags/kakao-api/"},{"name":"이미지 검색","slug":"이미지-검색","link":"/tags/%EC%9D%B4%EB%AF%B8%EC%A7%80-%EA%B2%80%EC%83%89/"},{"name":"다음 검색","slug":"다음-검색","link":"/tags/%EB%8B%A4%EC%9D%8C-%EA%B2%80%EC%83%89/"},{"name":"terminal","slug":"terminal","link":"/tags/terminal/"},{"name":"콜라츠 추측","slug":"콜라츠-추측","link":"/tags/%EC%BD%9C%EB%9D%BC%EC%B8%A0-%EC%B6%94%EC%B8%A1/"},{"name":"clone","slug":"clone","link":"/tags/clone/"},{"name":"branch","slug":"branch","link":"/tags/branch/"},{"name":"is-port-reachable","slug":"is-port-reachable","link":"/tags/is-port-reachable/"},{"name":"timestamp","slug":"timestamp","link":"/tags/timestamp/"},{"name":"on update","slug":"on-update","link":"/tags/on-update/"},{"name":"CURRENT_TIMESTAMP","slug":"CURRENT-TIMESTAMP","link":"/tags/CURRENT-TIMESTAMP/"},{"name":"prettier","slug":"prettier","link":"/tags/prettier/"},{"name":"setting.json","slug":"setting-json","link":"/tags/setting-json/"},{"name":"formatOnSave","slug":"formatOnSave","link":"/tags/formatOnSave/"}],"categories":[{"name":"aws","slug":"aws","link":"/categories/aws/"},{"name":"web","slug":"web","link":"/categories/web/"},{"name":"docker","slug":"docker","link":"/categories/docker/"},{"name":"react","slug":"react","link":"/categories/react/"},{"name":"programmers","slug":"programmers","link":"/categories/programmers/"},{"name":"sql","slug":"sql","link":"/categories/sql/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"nodejs","slug":"nodejs","link":"/categories/nodejs/"},{"name":"typescript","slug":"typescript","link":"/categories/typescript/"},{"name":"blog","slug":"blog","link":"/categories/blog/"},{"name":"cmd","slug":"cmd","link":"/categories/cmd/"},{"name":"etc","slug":"etc","link":"/categories/etc/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"playlist","slug":"playlist","link":"/categories/playlist/"},{"name":"swift","slug":"swift","link":"/categories/swift/"},{"name":"unity","slug":"unity","link":"/categories/unity/"},{"name":"vscode","slug":"vscode","link":"/categories/vscode/"},{"name":"markdown","slug":"markdown","link":"/categories/markdown/"},{"name":"생각","slug":"생각","link":"/categories/%EC%83%9D%EA%B0%81/"},{"name":"open api","slug":"open-api","link":"/categories/open-api/"},{"name":"windows","slug":"windows","link":"/categories/windows/"},{"name":"reg exp","slug":"reg-exp","link":"/categories/reg-exp/"},{"name":"정보처리기사","slug":"정보처리기사","link":"/categories/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/"},{"name":"kakao api","slug":"kakao-api","link":"/categories/kakao-api/"}]}